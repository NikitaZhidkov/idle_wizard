<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wizard Duels</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(180deg, #1e1e2e 0%, #232336 50%, #1a1a28 100%);
            min-height: 100vh;
            color: #d4d4dc;
            overflow-x: hidden;
        }
        .game-container { max-width: 400px; margin: 0 auto; padding: 8px; }

        /* Tabs */
        .tabs { display: flex; gap: 4px; margin-bottom: 8px; }
        .tab {
            flex: 1; padding: 6px; background: rgba(90, 80, 70, 0.25);
            border: 1px solid #5a5048; border-radius: 6px; color: #c8c4bc;
            font-size: 10px; cursor: pointer; font-family: Georgia, serif;
        }
        .tab.active { background: rgba(90, 80, 70, 0.5); border-color: #c9a857; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Header */
        .header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px; background: linear-gradient(135deg, rgba(70,65,58,0.4), rgba(55,50,45,0.4));
            border: 1px solid #4a4540; border-radius: 8px; margin-bottom: 8px;
        }
        .galleons { font-size: 16px; font-weight: bold; color: #c9a857; }
        .gems { font-size: 12px; color: #a987c9; }
        .level { font-size: 12px; color: #8a8a94; }

        /* Battle Area */
        .battle-area {
            border: 2px solid #3d3a35; border-radius: 12px;
            padding: 12px; margin-bottom: 8px;
            min-height: 160px; position: relative; overflow: hidden;
            transition: background 0.5s;
        }
        .room-background {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; transition: all 0.5s;
        }
        .room-decor {
            position: absolute; pointer-events: none; font-size: 16px; opacity: 0.6;
        }
        .magic-particles {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .ground {
            position: absolute; bottom: 0; left: 0; right: 0; height: 25px;
            transition: background 0.5s;
        }

        /* Room transition overlay */
        .room-transition {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(20,20,28,0.92); display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
        }
        .room-transition.active { opacity: 1; pointer-events: auto; }
        .room-victory { font-size: 24px; color: #c9a857; margin-bottom: 8px; }
        .room-loot { font-size: 14px; color: #c8c4bc; margin-bottom: 12px; }
        .room-next { font-size: 12px; color: #6a6a74; margin-bottom: 8px; }
        .room-continue-btn {
            padding: 12px 30px; font-size: 14px;
            background: linear-gradient(135deg, #b8944a, #a07830);
            border: none; border-radius: 8px; color: #1e1e2e;
            font-weight: bold; cursor: pointer; font-family: Georgia, serif;
            transition: transform 0.1s;
        }
        .room-continue-btn:hover { transform: scale(1.05); }
        .room-tip { font-size: 10px; color: #666; margin-top: 10px; font-style: italic; }

        /* Buff selection panel (below game area) */
        .buff-selection-panel {
            background: linear-gradient(135deg, rgba(35,30,45,0.95), rgba(45,40,55,0.95));
            border: 2px solid #7a6a50; border-radius: 12px;
            padding: 12px; margin-top: 10px;
        }
        .buff-title { font-size: 16px; color: #c9a857; margin-bottom: 10px; text-align: center; }
        .buff-choices { display: flex; flex-direction: column; gap: 10px; }
        .buff-choice {
            background: linear-gradient(135deg, rgba(55,50,65,0.6), rgba(45,40,55,0.6));
            border: 2px solid #4a4560; border-radius: 12px;
            padding: 12px; cursor: pointer; transition: all 0.2s;
            text-align: left;
        }
        .buff-choice:hover {
            border-color: #8a7a60;
            background: linear-gradient(135deg, rgba(65,60,80,0.7), rgba(55,50,70,0.7));
            transform: scale(1.02);
        }
        .buff-choice:active {
            transform: scale(0.98);
        }
        .buff-header { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
        .buff-icon { font-size: 28px; }
        .buff-name { font-size: 15px; font-weight: bold; color: #c9a857; flex: 1; }
        .buff-rarity { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: bold; }
        .buff-rarity.common { background: #555; color: #ccc; }
        .buff-rarity.rare { background: #4a6a9a; color: #d0e0f0; }
        .buff-rarity.epic { background: #6a4a8a; color: #e0d0f0; }
        .buff-rarity.legendary { background: linear-gradient(90deg, #a08040, #806030); color: #f0e8d0; }
        .buff-desc { font-size: 12px; color: #b0b0b8; line-height: 1.4; margin-bottom: 4px; }
        .buff-stats { font-size: 11px; color: #7aaaca; font-weight: bold; }

        /* Active buffs display */
        .active-buffs {
            display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px;
            max-height: 50px; overflow-y: auto;
        }
        .active-buff {
            background: rgba(55,50,65,0.5); border: 1px solid #4a4560;
            border-radius: 4px; padding: 2px 6px; font-size: 10px;
            display: flex; align-items: center; gap: 3px;
        }
        .active-buff-icon { font-size: 12px; }
        .active-buff-count { color: #c9a857; font-weight: bold; }
        .fighters {
            display: flex; justify-content: space-between; align-items: flex-end;
            height: 110px; padding: 0 10px; position: relative; z-index: 1;
        }
        .character { display: flex; flex-direction: column; align-items: center; }
        .character-sprite { width: 55px; height: 75px; transition: transform 0.1s; }
        .character-sprite.attacking { transform: translateX(15px); }
        .enemy-sprite { width: 50px; height: 60px; transition: transform 0.1s, filter 0.1s; }
        .enemy-sprite.hit { transform: translateX(8px); filter: brightness(2); }

        /* Health bars */
        .health-bar-container {
            width: 65px; height: 5px; background: #2a2a32;
            border-radius: 3px; margin-bottom: 3px; overflow: hidden;
        }
        .health-bar { height: 100%; transition: width 0.3s; }
        .health-bar.player { background: linear-gradient(90deg, #a04050, #703040); }
        .health-bar.enemy { background: linear-gradient(90deg, #408050, #306040); }
        .character-name { font-size: 10px; margin-bottom: 2px; color: #c9a857; }

        /* Magic type indicator */
        .magic-badge {
            font-size: 14px; position: absolute; top: -5px; right: -5px;
        }

        /* Creature status */
        .creature-status {
            position: absolute; top: 8px; right: 8px;
            display: flex; gap: 4px; flex-wrap: wrap; max-width: 100px;
        }
        .status-icon {
            width: 20px; height: 20px; border-radius: 4px;
            background: rgba(0,0,0,0.5); display: flex;
            align-items: center; justify-content: center; font-size: 12px;
        }

        /* House selector (stance) */
        .house-selector {
            display: flex; gap: 6px; margin-bottom: 8px; justify-content: center;
        }
        .house {
            padding: 6px 10px; border-radius: 8px; cursor: pointer;
            background: rgba(0,0,0,0.3); border: 2px solid transparent;
            font-size: 10px; text-align: center; transition: all 0.2s;
        }
        .house.active { border-color: #ffd700; }
        .house:hover { background: rgba(255,255,255,0.1); }
        .house-icon { font-size: 16px; }
        .house-name { font-size: 8px; }
        .house[data-house="gryffindor"] { border-color: #740001; }
        .house[data-house="gryffindor"].active { background: rgba(116,0,1,0.4); }
        .house[data-house="slytherin"] { border-color: #1a472a; }
        .house[data-house="slytherin"].active { background: rgba(26,71,42,0.4); }
        .house[data-house="ravenclaw"] { border-color: #0e1a40; }
        .house[data-house="ravenclaw"].active { background: rgba(14,26,64,0.4); }
        .house[data-house="hufflepuff"] { border-color: #ecb939; }
        .house[data-house="hufflepuff"].active { background: rgba(236,185,57,0.3); }

        /* Spells */
        .spells { display: flex; gap: 5px; justify-content: center; margin-bottom: 8px; flex-wrap: wrap; }
        .spell {
            width: 42px; height: 42px; border-radius: 8px;
            background: rgba(50,45,60,0.4); border: 2px solid #4a4560;
            cursor: pointer; position: relative; display: flex;
            align-items: center; justify-content: center; font-size: 18px;
        }
        .spell.ready { border-color: #9a8a60; box-shadow: 0 0 8px rgba(180,160,100,0.4); }
        .spell.on-cooldown { opacity: 0.5; }
        .spell-cooldown { position: absolute; bottom: 1px; font-size: 9px; color: #d4d4dc; }
        .spell-type {
            position: absolute; top: -4px; right: -4px; font-size: 9px;
            background: rgba(30,30,40,0.8); border-radius: 50%; padding: 2px;
        }

        /* Battle log */
        .battle-log {
            background: rgba(25,25,32,0.5); border: 1px solid #3a3a42;
            border-radius: 6px; padding: 5px; margin-bottom: 8px;
            height: 45px; overflow-y: auto; font-size: 10px;
        }
        .log-entry { margin: 1px 0; opacity: 0.9; }
        .log-damage { color: #c07070; }
        .log-gold { color: #c9a857; }
        .log-levelup { color: #9080a0; }
        .log-crit { color: #d06060; font-weight: bold; }
        .log-spell { color: #7aa8c0; }
        .log-effective { color: #70b070; }
        .log-resist { color: #c09050; }
        .log-boss { color: #a080b0; font-weight: bold; }

        /* Stats */
        .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 8px; }
        .stat { background: rgba(45,42,55,0.3); padding: 5px; border-radius: 6px; text-align: center; border: 1px solid #3a3848; }
        .stat-value { font-size: 13px; font-weight: bold; color: #c9a857; }
        .stat-label { font-size: 8px; color: #8a8a94; }

        /* Skill Tree */
        .skill-tree { padding: 10px; }
        .tree-header { text-align: center; margin-bottom: 10px; }
        .skill-points { font-size: 14px; color: #c9a857; }
        .tree-paths { display: flex; gap: 6px; }
        .tree-path {
            flex: 1; background: rgba(45,42,55,0.3);
            border: 1px solid #3a3848; border-radius: 10px; padding: 6px;
        }
        .path-header { text-align: center; margin-bottom: 6px; }
        .path-icon { font-size: 20px; }
        .path-name { font-size: 10px; font-weight: bold; }
        .tree-skills { display: flex; flex-direction: column; gap: 5px; }
        .tree-skill {
            background: rgba(30,30,38,0.4); border-radius: 6px;
            padding: 5px; cursor: pointer; border: 2px solid transparent;
            font-size: 9px;
        }
        .tree-skill.unlocked { border-color: #8a7a50; background: rgba(140,120,70,0.2); }
        .tree-skill.available { border-color: #6090a0; }
        .tree-skill.locked { opacity: 0.4; cursor: not-allowed; }
        .tree-skill-header { display: flex; align-items: center; gap: 4px; }
        .tree-skill-icon { font-size: 14px; }
        .tree-skill-name { font-size: 9px; font-weight: bold; }
        .tree-skill-cost { font-size: 8px; color: #c9a857; margin-left: auto; }
        .tree-skill-desc { font-size: 8px; color: #7a7a84; margin-top: 2px; }

        /* Shop */
        .shop { background: rgba(60,55,48,0.25); border: 1px solid #4a4540; border-radius: 10px; padding: 8px; }
        .shop-title { font-size: 12px; font-weight: bold; margin-bottom: 6px; text-align: center; color: #c9a857; }
        .shop-items { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; max-height: 180px; overflow-y: auto; }
        .shop-item {
            background: rgba(30,30,38,0.4); border-radius: 6px;
            padding: 6px; text-align: center; cursor: pointer;
            border: 2px solid transparent; transition: all 0.2s;
        }
        .shop-item:hover { background: rgba(80,80,90,0.2); }
        .shop-item.owned { border-color: #8a7a50; background: rgba(140,120,70,0.15); }
        .shop-item.equipped { border-color: #6090a0; background: rgba(96,144,160,0.15); }
        .shop-item.locked { opacity: 0.5; }
        .item-icon { font-size: 20px; }
        .item-name { font-size: 9px; }
        .item-price { font-size: 10px; color: #c9a857; }
        .item-stat { font-size: 8px; color: #7aa8c0; }
        .item-magic { font-size: 8px; color: #a080b0; }

        /* Bestiary */
        .bestiary { max-height: 280px; overflow-y: auto; }
        .creature-entry {
            background: rgba(30,30,38,0.4); border: 1px solid #3a3a42;
            border-radius: 8px; padding: 8px; margin-bottom: 6px;
            display: flex; align-items: center; gap: 10px;
        }
        .creature-entry.unknown { opacity: 0.4; }
        .creature-icon { font-size: 28px; }
        .creature-info { flex: 1; }
        .creature-title { font-size: 11px; font-weight: bold; display: flex; align-items: center; gap: 5px; }
        .creature-stats { font-size: 9px; color: #7a7a84; }
        .creature-weakness { font-size: 9px; color: #70b070; }
        .creature-ability { font-size: 9px; color: #a080b0; }

        /* Battle Creature Card */
        .battle-creature-card {
            background: linear-gradient(135deg, rgba(35,32,45,0.85), rgba(45,40,55,0.85));
            border: 2px solid #4a4560; border-radius: 12px;
            padding: 8px 10px;
            width: 120px; min-height: 100px;
            display: flex; flex-direction: column;
            position: relative;
        }
        .battle-creature-card.in-battle {
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .battle-creature-card.boss {
            border-color: #c9a857;
            background: linear-gradient(135deg, rgba(55,45,35,0.9), rgba(65,50,40,0.9));
            box-shadow: 0 0 20px rgba(200,160,60,0.3);
        }
        .battle-card-top {
            display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
        }
        .battle-creature-icon {
            font-size: 32px;
            filter: drop-shadow(0 0 10px rgba(200,200,255,0.4));
        }
        .battle-creature-card.boss .battle-creature-icon {
            filter: drop-shadow(0 0 12px rgba(255,200,100,0.5));
        }
        .battle-creature-info { flex: 1; }
        .battle-creature-name {
            font-size: 11px; font-weight: bold; color: #d4d4dc;
            display: flex; align-items: center; gap: 4px;
            flex-wrap: wrap;
        }
        .battle-creature-name .boss-crown { color: #c9a857; font-size: 12px; }
        .battle-creature-type {
            font-size: 14px;
        }
        .battle-creature-details {
            display: flex; gap: 6px; font-size: 9px;
            justify-content: space-between; margin-top: 4px;
        }
        .battle-creature-hp { color: #e07070; font-weight: bold; }
        .battle-creature-atk { color: #c9a857; }
        .battle-creature-weak { color: #70c070; }
        .battle-creature-abilities {
            display: flex; gap: 2px; margin-top: 2px;
        }
        .battle-creature-ability {
            font-size: 12px; opacity: 0.9;
        }
        .battle-hp-bar {
            width: 100%; height: 6px; background: #1a1a22;
            border-radius: 3px; overflow: hidden;
            border: 1px solid #3a3a42;
        }
        .battle-hp-fill {
            height: 100%; background: linear-gradient(90deg, #509060, #407050);
            transition: width 0.3s;
        }
        .battle-hp-fill.low { background: linear-gradient(90deg, #c05050, #904040); }
        .battle-hp-fill.boss { background: linear-gradient(90deg, #c9a857, #a08040); }

        /* Floating text */
        .floating-text {
            position: absolute; font-weight: bold; font-size: 14px; color: #c07070;
            animation: floatUp 0.8s ease-out forwards; pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-family: Georgia, serif;
        }
        .floating-text.gold { color: #c9a857; }
        .floating-text.crit { color: #d06060; font-size: 20px; }
        .floating-text.heal { color: #70b070; }
        .floating-text.spell { color: #7aa8c0; font-size: 18px; }
        .floating-text.effective { color: #70b070; font-size: 18px; }
        .floating-text.resist { color: #c09050; }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-35px) scale(0.8); }
        }

        /* Effects */
        .shake { animation: shake 0.15s ease-in-out; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }
        .particle {
            position: absolute; pointer-events: none; border-radius: 50%;
            animation: particle 0.6s ease-out forwards;
        }
        @keyframes particle {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translateY(-25px); }
        }
        .spell-effect {
            position: absolute; width: 30px; height: 30px;
            border-radius: 50%; pointer-events: none;
            animation: spellBurst 0.5s ease-out forwards;
        }
        @keyframes spellBurst {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        /* Spell visual effects */
        .spell-visual {
            position: absolute; pointer-events: none; z-index: 100;
            font-size: 40px; text-shadow: 0 0 20px currentColor;
        }
        .spell-visual.bolt { animation: spellBolt 0.4s ease-out forwards; }
        .spell-visual.fire { animation: spellFire 0.5s ease-out forwards; }
        .spell-visual.ice { animation: spellIce 0.5s ease-out forwards; }
        .spell-visual.slash { animation: spellSlash 0.3s ease-out forwards; }
        .spell-visual.explode { animation: spellExplode 0.5s ease-out forwards; }
        .spell-visual.heal { animation: spellHeal 0.6s ease-out forwards; color: #70b088; }
        .spell-visual.shield { animation: spellShield 0.5s ease-out forwards; color: #7aa0c0; }
        .spell-visual.death { animation: spellDeath 0.6s ease-out forwards; }
        .spell-visual.patronus { animation: spellPatronus 0.8s ease-out forwards; font-size: 60px; }
        .spell-visual.snake { animation: spellSnake 0.5s ease-out forwards; }
        .spell-visual.plant { animation: spellPlant 0.5s ease-out forwards; }
        .spell-visual.light { animation: spellLight 0.4s ease-out forwards; }
        .spell-visual.spark { animation: spellSpark 0.4s ease-out forwards; }

        @keyframes spellBolt {
            0% { transform: translateX(-100px) scale(0.5); opacity: 1; }
            100% { transform: translateX(0) scale(1.2); opacity: 0; }
        }
        @keyframes spellFire {
            0% { transform: scale(0.3) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.5) rotate(180deg); opacity: 1; }
            100% { transform: scale(2) rotate(360deg); opacity: 0; }
        }
        @keyframes spellIce {
            0% { transform: scale(0) rotate(-45deg); opacity: 1; filter: blur(0); }
            100% { transform: scale(2) rotate(45deg); opacity: 0; filter: blur(3px); }
        }
        @keyframes spellSlash {
            0% { transform: translateX(-50px) rotate(-45deg) scaleX(0.3); opacity: 1; }
            100% { transform: translateX(20px) rotate(45deg) scaleX(1.5); opacity: 0; }
        }
        @keyframes spellExplode {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(2); opacity: 1; }
            100% { transform: scale(3); opacity: 0; filter: blur(5px); }
        }
        @keyframes spellHeal {
            0% { transform: translateY(20px) scale(0.5); opacity: 0; }
            50% { transform: translateY(-10px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-30px) scale(0.8); opacity: 0; }
        }
        @keyframes spellShield {
            0% { transform: scale(0); opacity: 0; }
            30% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
        @keyframes spellDeath {
            0% { transform: scale(0) rotate(0deg); opacity: 1; filter: brightness(3); }
            50% { transform: scale(1.5) rotate(180deg); opacity: 1; filter: brightness(2); }
            100% { transform: scale(2) rotate(360deg); opacity: 0; filter: brightness(1); }
        }
        @keyframes spellPatronus {
            0% { transform: translateX(-80px) scale(0.3); opacity: 0; filter: brightness(2); }
            30% { transform: translateX(-40px) scale(1); opacity: 1; filter: brightness(3); }
            100% { transform: translateX(20px) scale(1.2); opacity: 0; filter: brightness(1); }
        }
        @keyframes spellSnake {
            0% { transform: translateX(-60px) scaleX(0.5); opacity: 1; }
            50% { transform: translateX(-20px) scaleX(1.2); opacity: 1; }
            100% { transform: translateX(10px) scaleX(0.8); opacity: 0; }
        }
        @keyframes spellPlant {
            0% { transform: translateY(30px) scale(0.3); opacity: 0; }
            50% { transform: translateY(0) scale(1.3); opacity: 1; }
            100% { transform: translateY(-20px) scale(1); opacity: 0; }
        }
        @keyframes spellLight {
            0% { transform: scale(0); opacity: 0; filter: brightness(1); }
            30% { transform: scale(2); opacity: 1; filter: brightness(5); }
            100% { transform: scale(3); opacity: 0; filter: brightness(1); }
        }
        @keyframes spellSpark {
            0% { transform: translateX(-80px) rotate(-30deg); opacity: 1; }
            100% { transform: translateX(0) rotate(30deg); opacity: 0; }
        }

        /* Battle info */
        .battle-info { position: absolute; top: 8px; left: 8px; }
        .floor-display { font-size: 11px; color: #9080a0; }
        .combo-display { font-size: 12px; font-weight: bold; color: #c9a857; }

        /* Spellbook */
        .spellbook { padding: 8px; }
        .spellbook-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; text-align: center; color: #c9a857; }
        .spellbook-list { display: flex; flex-direction: column; gap: 8px; max-height: 320px; overflow-y: auto; }
        .spell-entry {
            background: rgba(40,38,50,0.5); border: 2px solid #3a3848;
            border-radius: 10px; padding: 10px; display: flex; align-items: center; gap: 12px;
            transition: all 0.2s;
        }
        .spell-entry.unlocked { border-color: #6a6a50; background: rgba(60,58,50,0.4); }
        .spell-entry.locked { opacity: 0.5; }
        .spell-entry-icon { font-size: 28px; width: 36px; text-align: center; }
        .spell-entry-info { flex: 1; }
        .spell-entry-name { font-size: 13px; font-weight: bold; color: #d4d4dc; display: flex; align-items: center; gap: 6px; }
        .spell-entry-magic { font-size: 9px; padding: 2px 6px; border-radius: 4px; background: rgba(100,100,120,0.3); }
        .spell-entry-desc { font-size: 10px; color: #9a9aa4; margin-top: 3px; line-height: 1.3; }
        .spell-entry-cooldown { font-size: 10px; color: #7aa8c0; margin-top: 2px; }
        .spell-entry-status { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: bold; }
        .spell-entry-status.unlocked { background: rgba(100,140,80,0.3); color: #90c070; }
        .spell-entry-status.locked { background: rgba(80,80,100,0.3); color: #8080a0; }

        /* Offline popup */
        .offline-popup, .house-select-popup, .gameover-popup {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(15,15,20,0.92); display: flex;
            align-items: center; justify-content: center; z-index: 100;
        }
        .offline-content, .house-select-content, .gameover-content {
            background: linear-gradient(135deg, #252530, #2d2d3a);
            border: 2px solid #6a6050; border-radius: 12px;
            padding: 20px; text-align: center; max-width: 320px;
        }
        .offline-title, .house-select-title, .gameover-title { font-size: 16px; margin-bottom: 12px; color: #c9a857; }
        .offline-reward { font-size: 18px; margin: 6px 0; color: #c8c4bc; }
        .offline-btn, .gameover-btn {
            margin-top: 12px; padding: 10px 25px; font-size: 13px;
            background: linear-gradient(135deg, #9a8a60, #7a6a40);
            border: none; border-radius: 6px; color: #1e1e2e;
            font-weight: bold; cursor: pointer; font-family: Georgia, serif;
        }

        /* House selection */
        .house-select-title { font-size: 20px; margin-bottom: 8px; }
        .house-select-subtitle { font-size: 12px; color: #7a7a84; margin-bottom: 16px; }
        .house-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .house-option {
            padding: 12px 8px; border-radius: 10px; cursor: pointer;
            border: 3px solid transparent; transition: all 0.2s;
        }
        .house-option:hover { transform: scale(1.05); }
        .house-option[data-house="gryffindor"] { background: linear-gradient(135deg, #5a2020, #803030); border-color: #a08040; }
        .house-option[data-house="slytherin"] { background: linear-gradient(135deg, #1a3a2a, #2a4a3a); border-color: #8a8a8a; }
        .house-option[data-house="ravenclaw"] { background: linear-gradient(135deg, #1a2a40, #2a3a50); border-color: #7a5a30; }
        .house-option[data-house="hufflepuff"] { background: linear-gradient(135deg, #4a4035, #3a3028); border-color: #b09040; }
        .house-option-icon { font-size: 32px; }
        .house-option-name { font-size: 14px; font-weight: bold; margin: 6px 0; }
        .house-option-bonus { font-size: 10px; color: #a0a0a8; }
        .house-option-items { font-size: 9px; color: #c9a857; margin-top: 4px; }

        /* Game over */
        .gameover-content { max-width: 280px; }
        .gameover-title { font-size: 24px; color: #b06060; }
        .gameover-stats { margin: 16px 0; font-size: 12px; color: #a0a0a8; }
        .gameover-stats div { margin: 4px 0; }
        .gameover-floor { font-size: 18px; color: #c9a857; margin-bottom: 8px; }

        /* Boss Shield Minigame */
        .shield-minigame {
            display: none; margin-top: 10px; padding: 12px;
            background: linear-gradient(135deg, rgba(40,35,50,0.9), rgba(30,25,40,0.9));
            border: 2px solid #5a4a6a; border-radius: 12px;
        }
        .shield-minigame.active { display: block; }
        .shield-title { text-align: center; font-size: 12px; color: #c9a857; margin-bottom: 8px; }
        .shield-incoming {
            display: flex; align-items: center; justify-content: center;
            gap: 10px; margin-bottom: 12px; min-height: 70px;
            position: relative;
        }
        .shield-spell {
            font-size: 40px; text-shadow: 0 0 20px currentColor;
            position: relative; z-index: 2;
        }
        .shield-spell.flying {
            animation: spellFlyToPlayer 1.2s ease-in forwards;
        }
        .shield-spell.flying.tutorial {
            animation: spellFlyToPlayerSlow 3s ease-in forwards;
        }
        @keyframes spellFlyToPlayer {
            0% { transform: translateX(80px) translateY(-20px) scale(0.4); opacity: 0; }
            20% { opacity: 1; }
            100% { transform: translateX(-80px) translateY(10px) scale(1.3); opacity: 1; }
        }
        @keyframes spellFlyToPlayerSlow {
            0% { transform: translateX(80px) translateY(-20px) scale(0.4); opacity: 0; }
            15% { opacity: 1; }
            100% { transform: translateX(-80px) translateY(10px) scale(1.3); opacity: 1; }
        }
        .shield-player-icon {
            position: absolute; left: 20px; font-size: 30px; opacity: 0.8;
        }
        .shield-enemy-icon {
            position: absolute; right: 20px; font-size: 30px; opacity: 0.8;
        }
        .shield-buttons {
            display: flex; gap: 8px; justify-content: center;
        }
        .shield-btn {
            width: 60px; height: 60px; border-radius: 12px;
            border: 3px solid transparent; cursor: pointer;
            font-size: 24px; display: flex; align-items: center; justify-content: center;
            transition: all 0.15s; opacity: 0.8;
        }
        .shield-btn:hover { transform: scale(1.1); opacity: 1; }
        .shield-btn:active { transform: scale(0.95); }
        .shield-btn.red { background: linear-gradient(135deg, #8a3030, #a04040); border-color: #c05050; }
        .shield-btn.blue { background: linear-gradient(135deg, #303080, #4040a0); border-color: #5050c0; }
        .shield-btn.yellow { background: linear-gradient(135deg, #807830, #a09040); border-color: #c0b050; }
        .shield-btn.green { background: linear-gradient(135deg, #308030, #40a040); border-color: #50c050; }
        .shield-btn.highlight {
            animation: pulseHighlight 0.6s ease-in-out infinite;
            opacity: 1; transform: scale(1.15);
            box-shadow: 0 0 15px currentColor;
        }
        @keyframes pulseHighlight {
            0%, 100% { box-shadow: 0 0 15px currentColor, 0 0 25px currentColor; transform: scale(1.15); }
            50% { box-shadow: 0 0 25px currentColor, 0 0 45px currentColor; transform: scale(1.2); }
        }
        .shield-result {
            text-align: center; font-size: 14px; font-weight: bold;
            margin-top: 8px; min-height: 20px;
        }
        .shield-result.success { color: #70c070; }
        .shield-result.fail { color: #c07070; }
        .shield-timer {
            width: 100%; height: 8px; background: #2a2a3a;
            border-radius: 4px; margin-top: 8px; overflow: hidden;
        }
        .shield-timer-bar {
            height: 100%; background: linear-gradient(90deg, #c9a857, #a08030);
            transition: width 0.1s linear;
        }
        .shield-timer-bar.tutorial {
            background: linear-gradient(90deg, #70c070, #50a050);
        }

        /* Tutorial overlay */
        .shield-tutorial-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 15, 0.95); z-index: 200;
            display: flex; align-items: center; justify-content: center;
        }
        .shield-tutorial-content {
            background: linear-gradient(135deg, #2a2535, #352f40);
            border: 3px solid #c9a857; border-radius: 16px;
            padding: 24px; max-width: 320px; text-align: center;
        }
        .shield-tutorial-title {
            font-size: 20px; color: #c9a857; margin-bottom: 16px;
        }
        .shield-tutorial-text {
            font-size: 13px; color: #d4d4dc; line-height: 1.5; margin-bottom: 16px;
        }
        .shield-tutorial-demo {
            display: flex; justify-content: center; gap: 12px; margin: 20px 0;
        }
        .shield-tutorial-demo-btn {
            width: 50px; height: 50px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px;
        }
        .shield-tutorial-arrow {
            font-size: 24px; color: #c9a857; margin: 16px 0;
            animation: bounceArrow 0.8s ease-in-out infinite;
        }
        @keyframes bounceArrow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(8px); }
        }
        .shield-tutorial-btn {
            padding: 14px 32px; font-size: 15px;
            background: linear-gradient(135deg, #9a8a60, #7a6a40);
            border: none; border-radius: 8px; color: #1e1e2e;
            font-weight: bold; cursor: pointer; font-family: Georgia, serif;
            margin-top: 8px;
        }
        .shield-tutorial-btn:hover { transform: scale(1.05); }
        .shield-hint {
            font-size: 11px; color: #a0a0a8; margin-top: 8px;
            font-style: italic;
        }

        /* Spell Tutorial (beginning of game) */
        .spell-tutorial-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 15, 0.95); z-index: 200;
            display: flex; align-items: center; justify-content: center;
        }
        .spell-tutorial-content {
            background: linear-gradient(135deg, #2a2535, #352f40);
            border: 3px solid #c9a857; border-radius: 16px;
            padding: 24px; max-width: 340px; text-align: center;
        }
        .spell-tutorial-title {
            font-size: 22px; color: #c9a857; margin-bottom: 16px;
        }
        .spell-tutorial-text {
            font-size: 13px; color: #d4d4dc; line-height: 1.6; margin-bottom: 16px;
        }
        .spell-tutorial-step {
            background: rgba(50, 45, 60, 0.5); border: 1px solid #4a4560;
            border-radius: 12px; padding: 14px; margin: 12px 0;
            text-align: left;
        }
        .spell-tutorial-step-title {
            font-size: 14px; color: #c9a857; font-weight: bold;
            margin-bottom: 8px; display: flex; align-items: center; gap: 8px;
        }
        .spell-tutorial-step-text {
            font-size: 12px; color: #b0b0b8; line-height: 1.5;
        }
        .spell-tutorial-demo {
            display: flex; justify-content: center; gap: 8px; margin: 16px 0;
            flex-wrap: wrap;
        }
        .spell-tutorial-spell {
            width: 50px; height: 50px; border-radius: 10px;
            background: rgba(50, 45, 60, 0.6); border: 2px solid #6a6a50;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; position: relative;
        }
        .spell-tutorial-spell.highlight {
            border-color: #c9a857;
            box-shadow: 0 0 15px rgba(200, 170, 80, 0.5);
            animation: spellTutorialPulse 1s ease-in-out infinite;
        }
        @keyframes spellTutorialPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .spell-tutorial-label {
            font-size: 9px; color: #a0a0a8; margin-top: 4px;
        }
        .spell-tutorial-arrow {
            font-size: 20px; color: #c9a857; margin: 8px 0;
        }
        .spell-tutorial-btn {
            padding: 14px 40px; font-size: 16px;
            background: linear-gradient(135deg, #9a8a60, #7a6a40);
            border: none; border-radius: 8px; color: #1e1e2e;
            font-weight: bold; cursor: pointer; font-family: Georgia, serif;
            margin-top: 12px; transition: transform 0.1s;
        }
        .spell-tutorial-btn:hover { transform: scale(1.05); }
        .spell-tutorial-btn:active { transform: scale(0.98); }
        .spell-tutorial-page {
            display: none;
        }
        .spell-tutorial-page.active {
            display: block;
        }
        .spell-tutorial-dots {
            display: flex; justify-content: center; gap: 8px; margin-top: 16px;
        }
        .spell-tutorial-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: #4a4560;
        }
        .spell-tutorial-dot.active {
            background: #c9a857;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="tabs">
            <button class="tab active" data-tab="battle">‚öîÔ∏è Duel</button>
            <button class="tab" data-tab="spellbook">üìú Spells</button>
            <button class="tab" data-tab="skills">üìö Studies</button>
            <button class="tab" data-tab="shop">üè™ Diagon</button>
            <button class="tab" data-tab="bestiary">üìñ Creatures</button>
        </div>

        <div class="header">
            <div>
                <div class="galleons" id="gold">0 Galleons</div>
                <div class="gems" id="gems">0 Sickles | <span id="skillPoints">0 XP</span></div>
            </div>
            <div style="text-align: right;">
                <div class="level" id="level">Year 1</div>
                <div class="level" id="floor">Floor: 1</div>
            </div>
        </div>

        <!-- Battle Tab -->
        <div class="tab-content active" id="tab-battle">
            <div class="battle-area" id="battleArea">
                <div class="room-background" id="roomBackground"></div>
                <div class="magic-particles" id="magicParticles"></div>
                <div class="battle-info">
                    <div class="floor-display" id="floorDisplay"></div>
                    <div class="combo-display" id="comboDisplay"></div>
                </div>
                <div class="creature-status" id="creatureStatus"></div>
                <div class="fighters">
                    <div class="character" style="position: relative;">
                        <div class="character-name">Wizard</div>
                        <div class="health-bar-container"><div class="health-bar player" id="playerHealth"></div></div>
                        <canvas id="heroCanvas" class="character-sprite" width="55" height="75"></canvas>
                    </div>
                    <!-- Creature Display -->
                    <div class="character" id="battleCreatureCard">
                        <div class="character-name" id="battleCreatureName">Pixie</div>
                        <div class="health-bar-container"><div class="health-bar enemy" id="creatureHealth"></div></div>
                        <canvas id="creatureCanvas" class="enemy-sprite" width="50" height="60"></canvas>
                        <!-- Hidden elements for compatibility -->
                        <span id="battleCreatureType" style="display:none;"></span>
                        <span id="battleCreatureAbilities" style="display:none;"></span>
                        <span id="battleHpFill" style="display:none;"></span>
                        <span id="battleCreatureHp" style="display:none;"></span>
                        <span id="battleCreatureAtk" style="display:none;"></span>
                        <span id="battleCreatureWeak" style="display:none;"></span>
                        <span id="creatureMagic" style="display:none;"></span>
                    </div>
                </div>
                <!-- Hidden elements for compatibility -->
                <div id="creatureName" style="display:none;">Pixie</div>
                <div class="ground" id="roomGround"></div>
                <div class="room-transition" id="roomTransition">
                    <div class="room-victory">‚ú® Victory! ‚ú®</div>
                    <div class="room-loot" id="roomLoot">+0 Galleons</div>
                    <div class="room-next" id="roomNext">Room 2 awaits...</div>
                </div>
            </div>

            <div class="house-display" id="houseDisplay" style="text-align: center; margin-bottom: 4px;">
                <span id="currentHouseIcon" style="font-size: 20px;">ü¶Å</span>
                <span id="currentHouseName" style="font-size: 12px; color: #ffd700;"></span>
            </div>

            <div class="active-buffs" id="activeBuffs"></div>

            <div class="spells" id="spellsContainer"></div>
            <div class="battle-log" id="battleLog"></div>
            <div class="stats">
                <div class="stat"><div class="stat-value" id="atkStat">10</div><div class="stat-label">MAGIC</div></div>
                <div class="stat"><div class="stat-value" id="defStat">5</div><div class="stat-label">SHIELD</div></div>
                <div class="stat"><div class="stat-value" id="critStat">5%</div><div class="stat-label">CRIT</div></div>
                <div class="stat"><div class="stat-value" id="hpStat">100</div><div class="stat-label">HP</div></div>
            </div>

            <!-- Buff Selection (shown after victory, below game area) -->
            <div class="buff-selection-panel" id="buffSelectionPanel" style="display: none;">
                <div class="buff-title">üéÅ Choose a reward:</div>
                <div class="buff-choices" id="buffChoices"></div>
            </div>

            <!-- Boss Shield Minigame -->
            <div class="shield-minigame" id="shieldMinigame">
                <div class="shield-title" id="shieldTitle">üõ°Ô∏è Block the incoming spell!</div>
                <div class="shield-incoming" id="shieldIncoming">
                    <span class="shield-player-icon">üßô</span>
                    <span class="shield-enemy-icon" id="shieldEnemyIcon">üßå</span>
                </div>
                <div class="shield-buttons" id="shieldButtons">
                    <button class="shield-btn red" data-color="red">üî•</button>
                    <button class="shield-btn blue" data-color="blue">üíß</button>
                    <button class="shield-btn yellow" data-color="yellow">‚ö°</button>
                    <button class="shield-btn green" data-color="green">üåø</button>
                </div>
                <div class="shield-timer"><div class="shield-timer-bar" id="shieldTimerBar"></div></div>
                <div class="shield-result" id="shieldResult"></div>
                <div class="shield-hint" id="shieldHint"></div>
            </div>
        </div>

        <!-- Shield Tutorial Overlay -->
        <div class="shield-tutorial-overlay" id="shieldTutorialOverlay" style="display: none;">
            <div class="shield-tutorial-content">
                <div class="shield-tutorial-title">üõ°Ô∏è Shield Magic Tutorial</div>
                <div class="shield-tutorial-text">
                    The boss is casting spells at you!<br><br>
                    Watch the <b>color</b> of the incoming spell and <b>tap the matching shield button</b> to block it!
                </div>
                <div class="shield-tutorial-demo">
                    <div class="shield-tutorial-demo-btn" style="background: linear-gradient(135deg, #8a3030, #a04040);">üî•</div>
                    <div class="shield-tutorial-demo-btn" style="background: linear-gradient(135deg, #303080, #4040a0);">üíß</div>
                    <div class="shield-tutorial-demo-btn" style="background: linear-gradient(135deg, #807830, #a09040);">‚ö°</div>
                    <div class="shield-tutorial-demo-btn" style="background: linear-gradient(135deg, #308030, #40a040);">üåø</div>
                </div>
                <div class="shield-tutorial-arrow">‚¨áÔ∏è Tap the matching color! ‚¨áÔ∏è</div>
                <div class="shield-tutorial-text" style="font-size: 12px; color: #a0a0a8;">
                    The correct button will <b>glow</b> during this tutorial.<br>
                    Block all spells for bonus damage!
                </div>
                <button class="shield-tutorial-btn" id="shieldTutorialStartBtn">Got it! Let's go!</button>
            </div>
        </div>

        <!-- Spell Tutorial Overlay (beginning of game) -->
        <div class="spell-tutorial-overlay" id="spellTutorialOverlay" style="display: none;">
            <div class="spell-tutorial-content">
                <!-- Page 1: Welcome -->
                <div class="spell-tutorial-page active" id="spellTutorialPage1">
                    <div class="spell-tutorial-title">üßô Welcome, Young Wizard!</div>
                    <div class="spell-tutorial-text">
                        Your journey at Hogwarts begins now!<br>
                        Let me teach you how to cast spells in battle.
                    </div>
                    <div style="font-size: 60px; margin: 20px 0;">‚öîÔ∏èü™Ñ‚ú®</div>
                    <div class="spell-tutorial-text" style="color: #a0a0a8; font-size: 12px;">
                        You'll fight magical creatures automatically,<br>but spells give you special powers!
                    </div>
                    <button class="spell-tutorial-btn" onclick="nextSpellTutorialPage()">Next ‚Üí</button>
                    <div class="spell-tutorial-dots">
                        <div class="spell-tutorial-dot active"></div>
                        <div class="spell-tutorial-dot"></div>
                        <div class="spell-tutorial-dot"></div>
                    </div>
                </div>

                <!-- Page 2: Attack Spells -->
                <div class="spell-tutorial-page" id="spellTutorialPage2">
                    <div class="spell-tutorial-title">‚ö° Attack Spells</div>
                    <div class="spell-tutorial-step">
                        <div class="spell-tutorial-step-title">üí• Deal Extra Damage</div>
                        <div class="spell-tutorial-step-text">
                            Tap a spell button to cast it!<br>
                            Attack spells deal damage and apply effects like <b>stun</b>, <b>burn</b>, or <b>poison</b>.
                        </div>
                    </div>
                    <div class="spell-tutorial-demo">
                        <div class="spell-tutorial-spell highlight">‚ö°</div>
                        <div class="spell-tutorial-arrow">‚Üí</div>
                        <div class="spell-tutorial-spell">üêâ</div>
                        <div class="spell-tutorial-arrow">‚Üí</div>
                        <div style="font-size: 24px; color: #c07070;">-50 üí•</div>
                    </div>
                    <div class="spell-tutorial-text" style="font-size: 11px; color: #a0a0a8;">
                        Each spell has a cooldown - wait before casting again!
                    </div>
                    <button class="spell-tutorial-btn" onclick="nextSpellTutorialPage()">Next ‚Üí</button>
                    <div class="spell-tutorial-dots">
                        <div class="spell-tutorial-dot"></div>
                        <div class="spell-tutorial-dot active"></div>
                        <div class="spell-tutorial-dot"></div>
                    </div>
                </div>

                <!-- Page 3: Healing & Buffs -->
                <div class="spell-tutorial-page" id="spellTutorialPage3">
                    <div class="spell-tutorial-title">üíö Healing & Buffs</div>
                    <div class="spell-tutorial-step">
                        <div class="spell-tutorial-step-title">üõ°Ô∏è Protect Yourself</div>
                        <div class="spell-tutorial-step-text">
                            Some spells <b>heal</b> you or give you <b>buffs</b>!<br>
                            Use them when your health is low or to boost your power.
                        </div>
                    </div>
                    <div class="spell-tutorial-demo">
                        <div class="spell-tutorial-spell highlight">üíö</div>
                        <div class="spell-tutorial-arrow">‚Üí</div>
                        <div class="spell-tutorial-spell">üßô</div>
                        <div class="spell-tutorial-arrow">‚Üí</div>
                        <div style="font-size: 24px; color: #70c070;">+30% ‚ù§Ô∏è</div>
                    </div>
                    <div class="spell-tutorial-text" style="font-size: 11px; color: #a0a0a8;">
                        You'll unlock more spells as you progress!
                    </div>
                    <button class="spell-tutorial-btn" onclick="finishSpellTutorial()">Start Playing! ‚öîÔ∏è</button>
                    <div class="spell-tutorial-dots">
                        <div class="spell-tutorial-dot"></div>
                        <div class="spell-tutorial-dot"></div>
                        <div class="spell-tutorial-dot active"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Skills Tab -->
        <div class="tab-content" id="tab-skills">
            <div class="skill-tree">
                <div class="tree-header">
                    <div class="skill-points">Study Points: <span id="availableSP">0</span></div>
                </div>
                <div class="tree-paths" id="treePaths"></div>
            </div>
        </div>

        <!-- Shop Tab -->
        <div class="tab-content" id="tab-shop">
            <div class="shop">
                <div class="shop-title">üè™ Diagon Alley</div>
                <div class="shop-items" id="shopItems"></div>
            </div>
        </div>

        <!-- Bestiary Tab -->
        <div class="tab-content" id="tab-bestiary">
            <div class="bestiary" id="bestiaryList"></div>
        </div>

        <!-- Spellbook Tab -->
        <div class="tab-content" id="tab-spellbook">
            <div class="spellbook">
                <div class="spellbook-title">üìú Spellbook</div>
                <div class="spellbook-list" id="spellbookList"></div>
            </div>
        </div>
    </div>

    <div class="offline-popup" id="offlinePopup" style="display: none;">
        <div class="offline-content">
            <div class="offline-title">ü¶â Owl Post!</div>
            <div class="offline-reward" id="offlineGold">+0 Galleons</div>
            <button class="offline-btn" id="offlineClaimBtn">Collect!</button>
        </div>
    </div>

    <div class="house-select-popup" id="houseSelectPopup" style="display: none;">
        <div class="house-select-content">
            <div class="house-select-title">üé© The Sorting Hat</div>
            <div class="house-select-subtitle">Choose your house wisely, young wizard...</div>
            <div class="house-options">
                <div class="house-option" data-house="gryffindor">
                    <div class="house-option-icon">ü¶Å</div>
                    <div class="house-option-name">Gryffindor</div>
                    <div class="house-option-bonus">+20% Attack, -10% Defense</div>
                    <div class="house-option-items">üó°Ô∏è Sword of Gryffindor</div>
                </div>
                <div class="house-option" data-house="slytherin">
                    <div class="house-option-icon">üêç</div>
                    <div class="house-option-name">Slytherin</div>
                    <div class="house-option-bonus">+10% Attack, +5% Crit</div>
                    <div class="house-option-items">üìø Slytherin Locket</div>
                </div>
                <div class="house-option" data-house="ravenclaw">
                    <div class="house-option-icon">ü¶Ö</div>
                    <div class="house-option-name">Ravenclaw</div>
                    <div class="house-option-bonus">+8% Crit, +20% XP</div>
                    <div class="house-option-items">üëë Ravenclaw Diadem</div>
                </div>
                <div class="house-option" data-house="hufflepuff">
                    <div class="house-option-icon">ü¶°</div>
                    <div class="house-option-name">Hufflepuff</div>
                    <div class="house-option-bonus">+15% HP, +10% Defense</div>
                    <div class="house-option-items">üèÜ Hufflepuff Cup</div>
                </div>
            </div>
        </div>
    </div>

    <div class="gameover-popup" id="gameoverPopup" style="display: none;">
        <div class="gameover-content">
            <div class="gameover-title">üíÄ Defeated!</div>
            <div class="gameover-floor" id="gameoverFloor">Floor 1</div>
            <div class="gameover-stats">
                <div>üèÜ Creatures Defeated: <span id="gameoverKills">0</span></div>
                <div>üí∞ Gold Earned: <span id="gameoverGold">0</span></div>
                <div>‚≠ê Max Combo: <span id="gameoverCombo">0</span></div>
            </div>
            <button class="gameover-btn" id="gameoverRetryBtn">Try Again</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.ready();

        // Audio
        let audioCtx = null;
        function playSound(freq, type = 'sine', duration = 0.1) {
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        // Magic types (like elements)
        const MAGIC_TYPES = {
            CHARMS: { name: 'Charms', icon: '‚ú®', color: '#ffd700', beats: 'CREATURES', weakTo: 'DARK' },
            DARK: { name: 'Dark Arts', icon: 'üíÄ', color: '#4a0080', beats: 'CHARMS', weakTo: 'DEFENSE' },
            DEFENSE: { name: 'Defense', icon: 'üõ°Ô∏è', color: '#4169e1', beats: 'DARK', weakTo: 'CREATURES' },
            CREATURES: { name: 'Creatures', icon: 'üêâ', color: '#228b22', beats: 'DEFENSE', weakTo: 'CHARMS' },
            TRANSFIG: { name: 'Transfig', icon: 'üîÑ', color: '#9932cc', beats: null, weakTo: null },
            NONE: { name: 'Basic', icon: '‚ö™', color: '#888', beats: null, weakTo: null }
        };

        // Creature abilities
        const ABILITIES = {
            REGEN: { name: 'Regeneration', icon: 'üíö', desc: 'Heals each turn' },
            SHIELD: { name: 'Protego', icon: 'üõ°Ô∏è', desc: 'Blocks damage' },
            RAGE: { name: 'Enraged', icon: 'üò§', desc: 'Stronger when hurt' },
            POISON: { name: 'Venomous', icon: '‚ò†Ô∏è', desc: 'Poisons you' },
            DODGE: { name: 'Evasive', icon: 'üí®', desc: 'Dodges attacks' },
            REFLECT: { name: 'Reflect', icon: 'ü™û', desc: 'Returns damage' },
            DISARM: { name: 'Expelliarmus', icon: 'ü™Ñ', desc: 'Can disarm you' },
            FEAR: { name: 'Terrifying', icon: 'üò±', desc: 'Reduces your damage' }
        };

        // Hogwarts subjects (skill trees)
        const SKILL_TREES = {
            charms: {
                name: 'Charms', icon: '‚ú®', color: '#ffd700',
                skills: [
                    { id: 'lumos', name: 'Lumos Mastery', icon: 'üí°', desc: '+50% spell damage', cost: 1, effect: { spellDamage: 0.5 } },
                    { id: 'accio', name: 'Accio Expert', icon: 'üß≤', desc: '+20% gold drops', cost: 2, requires: 'lumos', effect: { goldBonus: 0.2 } },
                    { id: 'stupefy', name: 'Stupefy Master', icon: '‚ö°', desc: '+15% crit chance', cost: 3, requires: 'accio', effect: { crit: 15 } },
                    { id: 'patronus', name: 'Patronus', icon: 'ü¶å', desc: 'Unlock Expecto Patronum', cost: 4, requires: 'stupefy', effect: { unlockPatronus: true } }
                ]
            },
            darkarts: {
                name: 'Dark Arts', icon: 'üíÄ', color: '#4a0080',
                skills: [
                    { id: 'curse', name: 'Curse Knowledge', icon: 'üñ§', desc: '+25% vs Dark creatures', cost: 1, effect: { darkBonus: 0.25 } },
                    { id: 'crucio', name: 'Pain Resist', icon: 'üí™', desc: '-20% damage taken', cost: 2, requires: 'curse', effect: { damageReduce: 0.2 } },
                    { id: 'imperio', name: 'Mind Shield', icon: 'üß†', desc: 'Immune to Fear', cost: 3, requires: 'crucio', effect: { fearImmune: true } },
                    { id: 'avada', name: 'Killing Curse', icon: 'üíö', desc: 'Execute below 15% HP', cost: 4, requires: 'imperio', effect: { execute: true } }
                ]
            },
            defense: {
                name: 'Defense', icon: 'üõ°Ô∏è', color: '#4169e1',
                skills: [
                    { id: 'protego', name: 'Protego', icon: 'üõ°Ô∏è', desc: '+25% max HP', cost: 1, effect: { hpBonus: 0.25 } },
                    { id: 'impedimenta', name: 'Impedimenta', icon: 'üêå', desc: '+30% Shield', cost: 2, requires: 'protego', effect: { defBonus: 0.3 } },
                    { id: 'episkey', name: 'Episkey', icon: 'üíö', desc: 'Heal 3% HP per turn', cost: 3, requires: 'impedimenta', effect: { regen: 0.03 } },
                    { id: 'felix', name: 'Felix Felicis', icon: 'üçÄ', desc: 'Survive fatal hit once', cost: 4, requires: 'episkey', effect: { felix: true } }
                ]
            }
        };

        // Active spells - each house starts with their signature spell
        // Each spell has unique effect: buff (player), debuff (enemy), or special
        const SPELLS = [
            // House starter spells - each with unique effect
            { id: 'expelliarmus', name: 'Expelliarmus', icon: '‚ú®', cooldown: 6, magic: 'CHARMS', damage: 2, desc: 'Disarm: -20% enemy ATK for 3 turns', house: 'gryffindor', color: '#ff4444', visual: 'spark', debuff: { type: 'weaken', value: 0.2, turns: 3 } },
            { id: 'serpensortia', name: 'Serpensortia', icon: 'üêç', cooldown: 6, magic: 'DARK', damage: 2, desc: 'Poison: 5 damage/turn for 4 turns', house: 'slytherin', color: '#44ff44', visual: 'snake', debuff: { type: 'poison', value: 5, turns: 4 } },
            { id: 'lumos', name: 'Lumos Maxima', icon: 'üí°', cooldown: 6, magic: 'CHARMS', damage: 2, desc: 'Blind: +25% crit chance for 3 turns', house: 'ravenclaw', color: '#4488ff', visual: 'light', buff: { type: 'crit', value: 25, turns: 3 } },
            { id: 'herbivicus', name: 'Herbivicus', icon: 'üåø', cooldown: 6, magic: 'CREATURES', damage: 2, desc: 'Nature: Heal 10 HP + regen 3/turn for 3 turns', house: 'hufflepuff', color: '#ffdd44', visual: 'plant', buff: { type: 'regen', value: 3, turns: 3 }, healNow: 10 },

            // Learnable attack spells - each with unique effect
            { id: 'stupefy', name: 'Stupefy', icon: '‚ö°', cooldown: 8, magic: 'CHARMS', damage: 3, desc: 'Stun: Enemy skips next turn', locked: true, color: '#ff0000', visual: 'bolt', debuff: { type: 'stun', turns: 1 } },
            { id: 'incendio', name: 'Incendio', icon: 'üî•', cooldown: 10, magic: 'CHARMS', damage: 4, desc: 'Burn: 8 damage/turn for 3 turns', locked: true, color: '#ff6600', visual: 'fire', debuff: { type: 'burn', value: 8, turns: 3 } },
            { id: 'flipendo', name: 'Flipendo', icon: 'üí®', cooldown: 8, magic: 'DEFENSE', damage: 3, desc: 'Knockback: -30% enemy DEF for 2 turns', locked: true, color: '#88ccff', visual: 'wind', debuff: { type: 'armorBreak', value: 0.3, turns: 2 } },
            { id: 'glacius', name: 'Glacius', icon: '‚ùÑÔ∏è', cooldown: 10, magic: 'CHARMS', damage: 4, desc: 'Freeze: Slow enemy, +15% your ATK for 3 turns', locked: true, color: '#00ffff', visual: 'ice', buff: { type: 'atk', value: 0.15, turns: 3 }, debuff: { type: 'slow', value: 0.5, turns: 3 } },
            { id: 'depulso', name: 'Depulso', icon: 'üåÄ', cooldown: 9, magic: 'CHARMS', damage: 3, desc: 'Banish: Reduce all spell cooldowns by 2', locked: true, color: '#aa88ff', visual: 'push', special: 'reduceCooldowns' },
            { id: 'diffindo', name: 'Diffindo', icon: '‚úÇÔ∏è', cooldown: 7, magic: 'CHARMS', damage: 3, desc: 'Sever: +50% crit damage this fight', locked: true, color: '#ff88ff', visual: 'cut', buff: { type: 'critDmg', value: 0.5, turns: 99 } },
            { id: 'confringo', name: 'Confringo', icon: 'üí•', cooldown: 12, magic: 'DARK', damage: 5, desc: 'Blast: AoE burn 5/turn for 4 turns', locked: true, color: '#ff4400', visual: 'explode', debuff: { type: 'burn', value: 5, turns: 4 } },
            { id: 'bombarda', name: 'Bombarda', icon: 'üí£', cooldown: 14, magic: 'DARK', damage: 6, desc: 'Explode: Destroys 25% enemy max HP', locked: true, color: '#ff8800', visual: 'bomb', special: 'percentDamage', percentDmg: 0.25 },

            // Dark spells - powerful debuffs
            { id: 'sectumsempra', name: 'Sectumsempra', icon: 'üó°Ô∏è', cooldown: 12, magic: 'DARK', damage: 5, desc: 'Bleed: 10 damage/turn, can stack', locked: true, color: '#880000', visual: 'slash', debuff: { type: 'bleed', value: 10, turns: 5, stacks: true } },
            { id: 'crucio', name: 'Crucio', icon: '‚õìÔ∏è', cooldown: 15, magic: 'DARK', damage: 6, desc: 'Torture: -40% ATK & DEF for 4 turns', locked: true, color: '#440044', visual: 'torture', debuff: { type: 'torture', atkReduce: 0.4, defReduce: 0.4, turns: 4 } },
            { id: 'fiendfyre', name: 'Fiendfyre', icon: 'üî•üëπ', cooldown: 20, magic: 'DARK', damage: 10, desc: 'Hellfire: Burn 15/turn + fear for 5 turns', locked: true, color: '#ff0044', visual: 'hellfire', debuff: { type: 'hellfire', burnValue: 15, turns: 5, fear: true } },

            // Utility spells
            { id: 'episkey', name: 'Episkey', icon: 'üíö', cooldown: 15, magic: 'CHARMS', damage: 0, heal: 0.3, desc: 'Heal 30% HP + cure poison/burn', locked: true, color: '#00ff88', visual: 'heal', special: 'cleanse' },
            { id: 'vulnera', name: 'Vulnera Sanentur', icon: 'üíñ', cooldown: 20, magic: 'CHARMS', damage: 0, heal: 0.5, desc: 'Heal 50% HP + regen 5/turn for 5 turns', locked: true, color: '#ff88aa', visual: 'healbig', buff: { type: 'regen', value: 5, turns: 5 } },
            { id: 'protego', name: 'Protego', icon: 'üõ°Ô∏è', cooldown: 12, magic: 'DEFENSE', damage: 0, shield: 0.3, desc: 'Shield 30% HP + reflect 20% damage', locked: true, color: '#88aaff', visual: 'shield', buff: { type: 'reflect', value: 0.2, turns: 3 } },

            // Ultimate spells
            { id: 'patronus', name: 'Expecto Patronum', icon: 'ü¶å', cooldown: 25, magic: 'DEFENSE', damage: 8, desc: 'Guardian: +50% all stats for 5 turns, dispel fear', locked: true, color: '#ffffff', visual: 'patronus', buff: { type: 'empower', value: 0.5, turns: 5 }, special: 'dispelFear' },
            { id: 'avadakedavra', name: 'Avada Kedavra', icon: 'üíÄ', cooldown: 90, magic: 'DARK', damage: 0, desc: 'Killing curse: Instant kill, costs 50% of your HP (90s cooldown)', locked: true, color: '#00ff00', visual: 'death', special: 'avadaKedavra' }
        ];

        // Sprite sheet: 500x500, 4x4 grid, ~4px borders
        // Each cell is 125x125, sprite area starts at 4px offset, ~117x117 usable
        const SPRITE_CELL = 125;
        const SPRITE_BORDER = 4;
        const SPRITE_SIZE = 117;

        // Magical creatures (balanced for smooth first-run progression)
        // Sprite positions: row 0-2 for creatures, row 3 for bosses
        const CREATURES = [
            { name: 'Cornish Pixie', icon: 'üßö', magic: 'CREATURES', hp: 25, atk: 2, gold: 5, abilities: [], spriteX: 0, spriteY: 0 },
            { name: 'Doxy', icon: 'ü™∞', magic: 'CREATURES', hp: 30, atk: 3, gold: 8, abilities: ['POISON'], spriteX: 1, spriteY: 0 },
            { name: 'Grindylow', icon: 'üêô', magic: 'CREATURES', hp: 40, atk: 4, gold: 12, abilities: [], spriteX: 2, spriteY: 0 },
            { name: 'Red Cap', icon: 'üëπ', magic: 'DARK', hp: 50, atk: 5, gold: 15, abilities: ['RAGE'], spriteX: 3, spriteY: 0 },
            { name: 'Boggart', icon: 'üëª', magic: 'DARK', hp: 55, atk: 5, gold: 18, abilities: ['FEAR'], spriteX: 0, spriteY: 1 },
            { name: 'Hippogriff', icon: 'ü¶Ö', magic: 'CREATURES', hp: 70, atk: 7, gold: 30, abilities: ['DODGE'], spriteX: 1, spriteY: 1 },
            { name: 'Acromantula', icon: 'üï∑Ô∏è', magic: 'CREATURES', hp: 85, atk: 9, gold: 40, abilities: ['POISON', 'RAGE'], spriteX: 2, spriteY: 1 },
            { name: 'Dementor', icon: 'üë§', magic: 'DARK', hp: 100, atk: 11, gold: 60, abilities: ['FEAR', 'REGEN'], spriteX: 3, spriteY: 1 },
            { name: 'Werewolf', icon: 'üê∫', magic: 'CREATURES', hp: 120, atk: 13, gold: 80, abilities: ['RAGE', 'REGEN'], spriteX: 0, spriteY: 2 },
            { name: 'Hungarian Horntail', icon: 'üêâ', magic: 'CREATURES', hp: 150, atk: 16, gold: 120, abilities: ['SHIELD', 'RAGE'], spriteX: 1, spriteY: 2 },
            { name: 'Basilisk', icon: 'üêç', magic: 'DARK', hp: 180, atk: 18, gold: 150, abilities: ['POISON', 'FEAR', 'REFLECT'], spriteX: 2, spriteY: 2 }
        ];

        // Boss creatures (balanced for first-run winnable experience)
        // Row 3: Troll, Death Eater, Nagini, Voldemort
        const BOSSES = [
            { name: 'Troll', icon: 'üßå', magic: 'CREATURES', hp: 180, atk: 12, gold: 200, abilities: ['RAGE', 'SHIELD'], boss: true, spriteX: 3, spriteY: 2 },
            { name: 'Death Eater', icon: 'üíÄ', magic: 'DARK', hp: 220, atk: 15, gold: 300, abilities: ['DARK', 'DISARM', 'SHIELD'], boss: true, spriteX: 0, spriteY: 3 },
            { name: 'Nagini', icon: 'üêç', magic: 'DARK', hp: 280, atk: 18, gold: 400, abilities: ['POISON', 'REGEN', 'DODGE'], boss: true, spriteX: 1, spriteY: 3 },
            { name: 'Voldemort', icon: 'üêçüíÄ', magic: 'DARK', hp: 400, atk: 24, gold: 600, abilities: ['FEAR', 'REFLECT', 'DISARM', 'RAGE'], boss: true, spriteX: 2, spriteY: 3 }
        ];

        // Shop items (some are house-exclusive)
        const SHOP_ITEMS = [
            { id: 'wand1', name: 'Oak Wand', type: 'wand', icon: 'ü™Ñ', price: 50, atk: 5 },
            { id: 'wand2', name: 'Phoenix Wand', type: 'wand', icon: 'üî•', price: 200, atk: 12, magic: 'CHARMS' },
            { id: 'wand3', name: 'Elder Wand', type: 'wand', icon: '‚ö°', price: 800, atk: 30, magic: 'CHARMS', crit: 10 },
            { id: 'wand4', name: 'Yew Wand', type: 'wand', icon: 'üíÄ', price: 500, atk: 20, magic: 'DARK', crit: 5 },
            { id: 'robe1', name: 'School Robes', type: 'robe', icon: 'üëî', price: 75, def: 5, hp: 20 },
            { id: 'robe2', name: 'Dragon Hide', type: 'robe', icon: 'üêâ', price: 400, def: 20, hp: 60 },
            { id: 'robe3', name: 'Invisibility Cloak', type: 'robe', icon: 'üëª', price: 1000, def: 15, hp: 40, crit: 10 },
            { id: 'amulet1', name: 'Lucky Charm', type: 'amulet', icon: 'üçÄ', price: 100, crit: 5 },
            { id: 'amulet2', name: 'Horcrux Locket', type: 'amulet', icon: 'üìø', price: 600, atk: 15, hp: 50, magic: 'DARK' },
            { id: 'amulet3', name: 'Time-Turner', type: 'amulet', icon: '‚è≥', price: 800, def: 10, atk: 10, hp: 30 },
            { id: 'book1', name: 'Spellbook', type: 'book', icon: 'üìï', price: 60, atk: 3 },
            { id: 'book2', name: 'Monster Book', type: 'book', icon: 'üìó', price: 300, atk: 8, def: 8 },
            { id: 'book3', name: 'Half-Blood Prince', type: 'book', icon: 'üìò', price: 700, atk: 18, crit: 8 },
            // House-exclusive items (given free at start, can't be bought)
            { id: 'gryffindor_sword', name: 'Sword of Gryffindor', type: 'relic', icon: 'üó°Ô∏è', price: 0, atk: 25, crit: 5, house: 'gryffindor' },
            { id: 'slytherin_locket', name: 'Slytherin Locket', type: 'relic', icon: 'üìø', price: 0, atk: 15, crit: 10, magic: 'DARK', house: 'slytherin' },
            { id: 'ravenclaw_diadem', name: 'Ravenclaw Diadem', type: 'relic', icon: 'üëë', price: 0, atk: 10, crit: 8, xpBonus: 0.2, house: 'ravenclaw' },
            { id: 'hufflepuff_cup', name: 'Hufflepuff Cup', type: 'relic', icon: 'üèÜ', price: 0, def: 20, hp: 80, house: 'hufflepuff' }
        ];

        // Room themes for procedural generation
        const ROOM_THEMES = [
            { name: 'Dungeon', bg: ['#1a1a2e', '#0d0d1a'], ground: '#2a2a3a', decor: ['üïØÔ∏è', '‚õìÔ∏è', 'ü¶¥', 'üï∏Ô∏è'], particles: 'rgba(100,100,150,0.1)' },
            { name: 'Forest', bg: ['#0d2818', '#061a0d'], ground: '#1a3a1a', decor: ['üå≤', 'üçÑ', 'üåø', 'ü¶é'], particles: 'rgba(50,150,50,0.1)' },
            { name: 'Library', bg: ['#2d1b0e', '#1a0f08'], ground: '#3a2a1a', decor: ['üìö', 'üïØÔ∏è', 'üìú', 'ü™∂'], particles: 'rgba(200,150,100,0.1)' },
            { name: 'Castle', bg: ['#2a2a3a', '#1a1a2a'], ground: '#3a3a4a', decor: ['üè∞', '‚öîÔ∏è', 'üõ°Ô∏è', 'üö©'], particles: 'rgba(150,150,200,0.1)' },
            { name: 'Graveyard', bg: ['#1a1a1a', '#0a0a0a'], ground: '#2a2a2a', decor: ['üíÄ', 'ü™¶', 'ü¶á', 'üåô'], particles: 'rgba(100,100,100,0.15)' },
            { name: 'Lake', bg: ['#0a1a2a', '#051018'], ground: '#1a3a4a', decor: ['üåä', 'üêö', 'ü¶ë', 'üíé'], particles: 'rgba(100,150,200,0.1)' },
            { name: 'Tower', bg: ['#2a1a3a', '#1a0a2a'], ground: '#3a2a4a', decor: ['üåü', 'üîÆ', '‚≠ê', 'üåô'], particles: 'rgba(150,100,200,0.15)' },
            { name: 'Chamber', bg: ['#3a1a1a', '#2a0a0a'], ground: '#4a2a2a', decor: ['üî•', 'üíÄ', 'üêç', 'üëÅÔ∏è'], particles: 'rgba(200,50,50,0.1)' }
        ];

        // Roguelike buffs pool
        const BUFFS = [
            // Common buffs (60% chance)
            { id: 'atk1', name: 'Magic Boost', icon: '‚ö°', rarity: 'common', desc: 'Your spells hit slightly harder.', stats: '+3 Attack', effect: { atk: 3 } },
            { id: 'atk2', name: 'Wand Polish', icon: '‚ú®', rarity: 'common', desc: 'A well-maintained wand casts better.', stats: '+5 Attack', effect: { atk: 5 } },
            { id: 'def1', name: 'Shield Charm', icon: 'üõ°Ô∏è', rarity: 'common', desc: 'A basic protective enchantment.', stats: '+3 Defense', effect: { def: 3 } },
            { id: 'def2', name: 'Thick Robes', icon: 'üß•', rarity: 'common', desc: 'Extra padding against attacks.', stats: '+5 Defense', effect: { def: 5 } },
            { id: 'hp1', name: 'Vitality', icon: '‚ù§Ô∏è', rarity: 'common', desc: 'You feel more energetic.', stats: '+15 Max HP', effect: { hp: 15 } },
            { id: 'hp2', name: 'Endurance', icon: 'üí™', rarity: 'common', desc: 'Your stamina increases.', stats: '+25 Max HP', effect: { hp: 25 } },
            { id: 'crit1', name: 'Lucky Penny', icon: 'ü™ô', rarity: 'common', desc: 'Fortune favors the bold.', stats: '+2% Crit', effect: { crit: 2 } },
            { id: 'gold1', name: 'Midas Touch', icon: 'üí∞', rarity: 'common', desc: 'Enemies drop more gold.', stats: '+10% Gold', effect: { goldBonus: 0.1 } },
            { id: 'heal1', name: 'Minor Healing', icon: 'üíö', rarity: 'common', desc: 'Restore some health.', stats: 'Heal 20 HP', effect: { healNow: 20 } },

            // Rare buffs (30% chance)
            { id: 'atk3', name: 'Power Surge', icon: 'üî•', rarity: 'rare', desc: 'Raw magical power flows through you.', stats: '+10 Attack', effect: { atk: 10 } },
            { id: 'def3', name: 'Iron Skin', icon: 'ü™®', rarity: 'rare', desc: 'Your skin hardens like stone.', stats: '+10 Defense', effect: { def: 10 } },
            { id: 'hp3', name: 'Giant\'s Blood', icon: 'üß™', rarity: 'rare', desc: 'You grow stronger and tougher.', stats: '+50 Max HP', effect: { hp: 50 } },
            { id: 'crit2', name: 'Eagle Eye', icon: 'ü¶Ö', rarity: 'rare', desc: 'You spot weaknesses easily.', stats: '+5% Crit', effect: { crit: 5 } },
            { id: 'critdmg1', name: 'Cruel Strikes', icon: 'üí•', rarity: 'rare', desc: 'Critical hits deal more damage.', stats: '+25% Crit Damage', effect: { critDmg: 0.25 } },
            { id: 'lifesteal1', name: 'Vampiric Wand', icon: 'üßõ', rarity: 'rare', desc: 'Drain life from your enemies.', stats: 'Heal 5% of damage dealt', effect: { lifesteal: 0.05 } },
            { id: 'regen1', name: 'Regeneration', icon: 'üåø', rarity: 'rare', desc: 'Slowly recover health in battle.', stats: 'Heal 2 HP per turn', effect: { regenFlat: 2 } },
            { id: 'dodge1', name: 'Quick Reflexes', icon: 'üí®', rarity: 'rare', desc: 'Sometimes evade enemy attacks.', stats: '+8% Dodge chance', effect: { dodge: 8 } },
            { id: 'thorns1', name: 'Thorns', icon: 'üåπ', rarity: 'rare', desc: 'Enemies hurt themselves attacking you.', stats: 'Return 15% damage', effect: { thorns: 0.15 } },
            { id: 'xp1', name: 'Quick Learner', icon: 'üìö', rarity: 'rare', desc: 'Gain experience faster.', stats: '+25% XP gain', effect: { xpBonus: 0.25 } },
            { id: 'heal2', name: 'Greater Healing', icon: 'üíñ', rarity: 'rare', desc: 'Restore a good amount of health.', stats: 'Heal 50 HP', effect: { healNow: 50 } },

            // Epic buffs (8% chance)
            { id: 'atk4', name: 'Arcane Might', icon: 'üåü', rarity: 'epic', desc: 'Overwhelming magical power surges within.', stats: '+20 Attack', effect: { atk: 20 } },
            { id: 'def4', name: 'Diamond Shield', icon: 'üíé', rarity: 'epic', desc: 'An impenetrable magical barrier.', stats: '+20 Defense', effect: { def: 20 } },
            { id: 'hp4', name: 'Dragon Heart', icon: 'üêâ', rarity: 'epic', desc: 'The vitality of a dragon flows in you.', stats: '+100 Max HP', effect: { hp: 100 } },
            { id: 'crit3', name: 'Assassin\'s Mark', icon: 'üéØ', rarity: 'epic', desc: 'Strike with deadly precision.', stats: '+10% Crit', effect: { crit: 10 } },
            { id: 'allstats1', name: 'Blessing', icon: 'üëº', rarity: 'epic', desc: 'A divine blessing enhances all abilities.', stats: '+8 ATK, +8 DEF, +40 HP', effect: { atk: 8, def: 8, hp: 40 } },
            { id: 'lifesteal2', name: 'Soul Drain', icon: 'üëª', rarity: 'epic', desc: 'Absorb the essence of defeated foes.', stats: 'Heal 10% of damage dealt', effect: { lifesteal: 0.1 } },
            { id: 'execute1', name: 'Executioner', icon: '‚ö∞Ô∏è', rarity: 'epic', desc: 'Deal massive damage to wounded enemies.', stats: '+50% damage below 30% HP', effect: { executeDmg: 0.5 } },
            { id: 'spellpower1', name: 'Spell Mastery', icon: 'üìñ', rarity: 'epic', desc: 'Your active spells are empowered.', stats: '+40% Spell damage', effect: { spellPower: 0.4 } },
            { id: 'fullheal', name: 'Phoenix Tears', icon: 'üî•', rarity: 'epic', desc: 'Completely restore your health.', stats: 'Full HP restore', effect: { fullHeal: true } },

            // Spell unlocks - Common (basic attack spells)
            { id: 'spell_stupefy', name: 'Learn Stupefy', icon: '‚ö°', rarity: 'common', desc: 'Learn the stunning spell.', stats: 'Unlock Stupefy', effect: { unlockSpell: 'stupefy' } },
            { id: 'spell_flipendo', name: 'Learn Flipendo', icon: 'üí®', rarity: 'common', desc: 'Learn the knockback jinx.', stats: 'Unlock Flipendo', effect: { unlockSpell: 'flipendo' } },
            { id: 'spell_diffindo', name: 'Learn Diffindo', icon: '‚úÇÔ∏è', rarity: 'common', desc: 'Learn the severing charm.', stats: 'Unlock Diffindo', effect: { unlockSpell: 'diffindo' } },

            // Spell unlocks - Rare (stronger spells)
            { id: 'spell_incendio', name: 'Learn Incendio', icon: 'üî•', rarity: 'rare', desc: 'Learn the fire-making spell.', stats: 'Unlock Incendio', effect: { unlockSpell: 'incendio' } },
            { id: 'spell_glacius', name: 'Learn Glacius', icon: '‚ùÑÔ∏è', rarity: 'rare', desc: 'Learn the freezing spell.', stats: 'Unlock Glacius', effect: { unlockSpell: 'glacius' } },
            { id: 'spell_depulso', name: 'Learn Depulso', icon: 'üåÄ', rarity: 'rare', desc: 'Learn the banishing charm.', stats: 'Unlock Depulso', effect: { unlockSpell: 'depulso' } },
            { id: 'spell_episkey', name: 'Learn Episkey', icon: 'üíö', rarity: 'rare', desc: 'Learn the healing spell.', stats: 'Unlock Episkey', effect: { unlockSpell: 'episkey' } },
            { id: 'spell_protego', name: 'Learn Protego', icon: 'üõ°Ô∏è', rarity: 'rare', desc: 'Learn the shield charm.', stats: 'Unlock Protego', effect: { unlockSpell: 'protego' } },

            // Spell unlocks - Epic (powerful spells)
            { id: 'spell_confringo', name: 'Learn Confringo', icon: 'üí•', rarity: 'epic', desc: 'Learn the blasting curse.', stats: 'Unlock Confringo', effect: { unlockSpell: 'confringo' } },
            { id: 'spell_bombarda', name: 'Learn Bombarda', icon: 'üí£', rarity: 'epic', desc: 'Learn the explosive spell.', stats: 'Unlock Bombarda', effect: { unlockSpell: 'bombarda' } },
            { id: 'spell_sectumsempra', name: 'Learn Sectumsempra', icon: 'üó°Ô∏è', rarity: 'epic', desc: 'Learn the dark cutting curse.', stats: 'Unlock Sectumsempra', effect: { unlockSpell: 'sectumsempra' } },
            { id: 'spell_vulnera', name: 'Learn Vulnera Sanentur', icon: 'üíñ', rarity: 'epic', desc: 'Learn powerful healing magic.', stats: 'Unlock Vulnera Sanentur', effect: { unlockSpell: 'vulnera' } },

            // Spell unlocks - Legendary (ultimate spells)
            { id: 'spell_crucio', name: 'Learn Crucio', icon: '‚õìÔ∏è', rarity: 'legendary', desc: 'Learn the torture curse.', stats: 'Unlock Crucio', effect: { unlockSpell: 'crucio' } },
            { id: 'spell_patronus', name: 'Learn Patronus', icon: 'ü¶å', rarity: 'legendary', desc: 'Learn to conjure a Patronus.', stats: 'Unlock Expecto Patronum', effect: { unlockSpell: 'patronus' } },
            { id: 'spell_fiendfyre', name: 'Learn Fiendfyre', icon: 'üî•üëπ', rarity: 'legendary', desc: 'Learn cursed fire magic.', stats: 'Unlock Fiendfyre', effect: { unlockSpell: 'fiendfyre' } },
            { id: 'spell_avadakedavra', name: 'Learn Avada Kedavra', icon: 'üíÄ', rarity: 'legendary', desc: 'Learn the killing curse.', stats: 'Unlock Avada Kedavra', effect: { unlockSpell: 'avadakedavra' } },

            // Legendary buffs (2% chance)
            { id: 'godmode', name: 'Invincibility', icon: '‚≠ê', rarity: 'legendary', desc: 'Become temporarily invulnerable. Blocks 3 lethal hits.', stats: '3 Death saves', effect: { deathSaves: 3 } },
            { id: 'doubledmg', name: 'Dual Cast', icon: 'üîÆ', rarity: 'legendary', desc: 'Every attack hits twice.', stats: 'Double attack', effect: { doubleAttack: true } },
            { id: 'megastats', name: 'Elder Power', icon: 'üßô', rarity: 'legendary', desc: 'Channel the power of ancient wizards.', stats: '+25 ATK, +25 DEF, +150 HP', effect: { atk: 25, def: 25, hp: 150 } },
            { id: 'goldrain', name: 'Leprechaun\'s Luck', icon: 'üçÄ', rarity: 'legendary', desc: 'Gold rains down upon you.', stats: '+100% Gold, +500 Gold now', effect: { goldBonus: 1.0, goldNow: 500 } },
            { id: 'critgod', name: 'Death\'s Scythe', icon: 'üíÄ', rarity: 'legendary', desc: 'Critical hits are devastating.', stats: '+20% Crit, +100% Crit Damage', effect: { crit: 20, critDmg: 1.0 } }
        ];

        // Game state
        let game = {
            gold: 0, gems: 0, level: 1, floor: 1, exp: 0, expToLevel: 100,
            baseAtk: 10, baseDef: 5, baseHp: 100, baseCrit: 5,
            currentHp: 100, maxHp: 100,
            equipment: { wand: null, robe: null, amulet: null, book: null, relic: null },
            owned: [], soulGems: 0, prestigeCount: 0,
            skillPoints: 0, unlockedSkills: [],
            house: null, houseChosen: false, gameStarted: false,
            combo: 0, maxCombo: 0,
            spellCooldowns: {}, poisonStacks: 0, fearDebuff: false,
            unlockedSpells: ['stupefy'],
            // Combat buffs/debuffs (reset each fight)
            combatBuffs: [], // player buffs: { type, value, turns }
            combatDebuffs: [], // enemy debuffs: { type, value, turns }
            selectingBuff: false, // freeze cooldowns while selecting
            discoveredCreatures: [], totalKills: 0, totalGoldEarned: 0,
            lastOnline: Date.now(), felixUsed: false,
            runKills: 0, runGold: 0, bestFloor: 0,
            inBattle: false, roomSeed: 0, lastGoldGain: 0,
            // Roguelike buffs for current run
            activeBuffs: [],
            buffStats: { atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0, goldBonus: 0, xpBonus: 0, lifesteal: 0, regenFlat: 0, dodge: 0, thorns: 0, executeDmg: 0, spellPower: 0, deathSaves: 0, doubleAttack: false },
            // Tutorials completed
            spellTutorialDone: false,
            shieldTutorialDone: false
        };

        // Clear saved game on page load - always start fresh
        localStorage.removeItem('wizardDuels');

        let currentCreature = null;
        let creatureHp = 0;
        let creatureBuffs = {};
        let turnCount = 0;

        // Boss shield minigame state
        let shieldGame = {
            active: false,
            currentColor: null,
            timeLeft: 0,
            timerInterval: null,
            isTutorial: false,
            bossSpellQueue: [],
            spellsBlocked: 0,
            spellsMissed: 0
        };

        // Shield spell colors and their icons
        const SHIELD_COLORS = {
            red: { icon: 'üî•', name: 'Fire', spellIcon: 'üî•üí•' },
            blue: { icon: 'üíß', name: 'Water', spellIcon: 'üíßüåä' },
            yellow: { icon: '‚ö°', name: 'Lightning', spellIcon: '‚ö°‚ú®' },
            green: { icon: 'üåø', name: 'Nature', spellIcon: 'üåøüçÉ' }
        };

        const battleArea = document.getElementById('battleArea');
        const battleLog = document.getElementById('battleLog');
        const heroCanvas = document.getElementById('heroCanvas');
        const creatureCanvas = document.getElementById('creatureCanvas');
        const heroCtx = heroCanvas.getContext('2d');
        const creatureCtx = creatureCanvas.getContext('2d');

        // Load creature sprite sheet
        const creatureSpriteSheet = new Image();
        creatureSpriteSheet.crossOrigin = 'anonymous';
        let spriteSheetLoaded = false;
        creatureSpriteSheet.onload = () => {
            console.log('Sprite sheet loaded successfully:', creatureSpriteSheet.width, 'x', creatureSpriteSheet.height);
            spriteSheetLoaded = true;
            if (currentCreature) drawCreature();
        };
        creatureSpriteSheet.onerror = (e) => {
            console.error('Failed to load sprite sheet:', e);
        };
        creatureSpriteSheet.src = 'creatures.png?v=3';

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');

                // Refresh content when tab is opened
                if (tab.dataset.tab === 'spellbook') renderSpellbook();
                if (tab.dataset.tab === 'skills') renderSkillTree();
                if (tab.dataset.tab === 'shop') renderShop();
                if (tab.dataset.tab === 'bestiary') renderBestiary();
            });
        });

        // Houses
        document.querySelectorAll('.house').forEach(h => {
            h.addEventListener('click', () => {
                document.querySelectorAll('.house').forEach(ho => ho.classList.remove('active'));
                h.classList.add('active');
                game.house = h.dataset.house;
                drawWizard();
                updateUI();
                saveGame();
            });
        });

        function getSkillEffect(name) {
            for (const tree of Object.values(SKILL_TREES)) {
                for (const skill of tree.skills) {
                    if (game.unlockedSkills.includes(skill.id) && skill.effect[name]) {
                        return skill.effect[name];
                    }
                }
            }
            return null;
        }

        function hasSkill(name) { return getSkillEffect(name) !== null; }

        function getStats() {
            const bs = game.buffStats;
            let atk = game.baseAtk + (game.level - 1) * 2;
            let def = game.baseDef + (game.level - 1);
            let hp = game.baseHp + (game.level - 1) * 10;
            let crit = game.baseCrit;
            let wandMagic = 'NONE';
            let xpBonus = 0;

            for (const type in game.equipment) {
                const id = game.equipment[type];
                if (id) {
                    const item = SHOP_ITEMS.find(i => i.id === id);
                    if (item) {
                        atk += item.atk || 0;
                        def += item.def || 0;
                        hp += item.hp || 0;
                        crit += item.crit || 0;
                        if (item.magic && (type === 'wand' || type === 'relic')) wandMagic = item.magic;
                        if (item.xpBonus) xpBonus += item.xpBonus;
                    }
                }
            }

            // Buff stats from roguelike rewards
            atk += bs.atk;
            def += bs.def;
            hp += bs.hp;
            crit += bs.crit;
            xpBonus += bs.xpBonus;

            // Skill bonuses
            const hpBonus = getSkillEffect('hpBonus');
            if (hpBonus) hp *= (1 + hpBonus);
            const defBonus = getSkillEffect('defBonus');
            if (defBonus) def *= (1 + defBonus);
            const critBonus = getSkillEffect('crit');
            if (critBonus) crit += critBonus;
            const dmgReduce = getSkillEffect('damageReduce');

            // House bonuses
            if (game.house === 'gryffindor') { atk *= 1.2; def *= 0.9; }
            else if (game.house === 'slytherin') { atk *= 1.1; crit += 5; }
            else if (game.house === 'ravenclaw') { crit += 8; xpBonus += 0.2; }
            else if (game.house === 'hufflepuff') { hp *= 1.15; def *= 1.1; }

            // Fear debuff
            if (game.fearDebuff && !hasSkill('fearImmune')) atk *= 0.7;

            return {
                atk: Math.floor(atk), def: Math.floor(def), hp: Math.floor(hp), crit, wandMagic,
                dmgReduce: dmgReduce || 0, xpBonus,
                // Buff special stats
                critDmg: 1 + bs.critDmg,
                goldBonus: bs.goldBonus,
                lifesteal: bs.lifesteal,
                regenFlat: bs.regenFlat,
                dodge: bs.dodge,
                thorns: bs.thorns,
                executeDmg: bs.executeDmg,
                spellPower: bs.spellPower,
                deathSaves: bs.deathSaves,
                doubleAttack: bs.doubleAttack
            };
        }

        function getMagicMultiplier(attackMagic, defenderMagic) {
            const att = MAGIC_TYPES[attackMagic];
            const def = MAGIC_TYPES[defenderMagic];
            if (!att || !def) return 1;
            if (att.beats === defenderMagic) return 1.5;
            if (att.weakTo === defenderMagic) return 0.6;
            return 1;
        }

        function updateUI() {
            const stats = getStats();
            game.maxHp = stats.hp;
            if (game.currentHp > stats.hp) game.currentHp = stats.hp;

            document.getElementById('gold').textContent = `${formatNum(game.gold)} Galleons`;
            document.getElementById('gems').textContent = `${game.gems} Sickles | ${game.skillPoints} XP`;
            document.getElementById('level').textContent = `Year ${game.level}`;
            document.getElementById('floor').textContent = `Floor: ${game.floor}`;
            document.getElementById('availableSP').textContent = game.skillPoints;

            document.getElementById('atkStat').textContent = stats.atk;
            document.getElementById('defStat').textContent = stats.def;
            document.getElementById('critStat').textContent = stats.crit + '%';
            document.getElementById('hpStat').textContent = stats.hp;

            document.getElementById('playerHealth').style.width = `${(game.currentHp / stats.hp) * 100}%`;

            const comboEl = document.getElementById('comboDisplay');
            comboEl.textContent = game.combo > 1 ? `${game.combo}x Combo!` : '';

            document.getElementById('floorDisplay').textContent = game.floor % 5 === 0 ? '‚ö†Ô∏è BOSS!' : '';

            renderSpellBar();
            renderCreatureStatus();
        }

        function formatNum(n) {
            if (n >= 1000000) return (n/1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n/1000).toFixed(1) + 'K';
            return Math.floor(n);
        }

        function addLog(text, type = '') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = text;
            battleLog.appendChild(entry);
            battleLog.scrollTop = battleLog.scrollHeight;
            while (battleLog.children.length > 12) battleLog.removeChild(battleLog.firstChild);
        }

        function showFloat(text, x, y, type = '') {
            const el = document.createElement('div');
            el.className = `floating-text ${type}`;
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            battleArea.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = (x + Math.random() * 25 - 12) + 'px';
                p.style.top = (y + Math.random() * 25 - 12) + 'px';
                p.style.width = p.style.height = (4 + Math.random() * 6) + 'px';
                p.style.background = color;
                battleArea.appendChild(p);
                setTimeout(() => p.remove(), 600);
            }
        }

        function spellEffect(x, y, color) {
            const el = document.createElement('div');
            el.className = 'spell-effect';
            el.style.left = (x - 15) + 'px';
            el.style.top = (y - 15) + 'px';
            el.style.background = `radial-gradient(circle, ${color}, transparent)`;
            battleArea.appendChild(el);
            setTimeout(() => el.remove(), 500);
        }

        // Visual spell effects with icons
        const SPELL_VISUALS = {
            spark: '‚ú®', bolt: '‚ö°', fire: 'üî•', ice: '‚ùÑÔ∏è', wind: 'üí®', push: 'üåÄ',
            cut: '‚úÇÔ∏è', explode: 'üí•', bomb: 'üí£', slash: 'üó°Ô∏è', torture: '‚õìÔ∏è',
            hellfire: 'üî•üëπ', heal: 'üíö', healbig: 'üíñ', shield: 'üõ°Ô∏è',
            patronus: 'ü¶å', death: 'üíÄ', snake: 'üêç', plant: 'üåø', light: 'üí°'
        };

        function castSpellVisual(spell, targetX, targetY) {
            const visual = spell.visual || 'bolt';
            const icon = SPELL_VISUALS[visual] || '‚ú®';
            const color = spell.color || '#ffffff';

            const el = document.createElement('div');
            el.className = `spell-visual ${visual}`;
            el.textContent = icon;
            el.style.left = targetX + 'px';
            el.style.top = targetY + 'px';
            el.style.color = color;
            battleArea.appendChild(el);

            const duration = visual === 'patronus' ? 800 : (visual === 'heal' || visual === 'healbig') ? 600 : 500;
            setTimeout(() => el.remove(), duration);
        }

        function renderSpellBar() {
            const container = document.getElementById('spellsContainer');
            container.innerHTML = '';

            SPELLS.forEach(spell => {
                // Only show spells that are unlocked
                if (!game.unlockedSpells.includes(spell.id)) return;

                const cd = game.spellCooldowns[spell.id] || 0;
                const div = document.createElement('div');
                div.className = `spell ${cd <= 0 ? 'ready' : 'on-cooldown'}`;
                div.innerHTML = `
                    ${spell.icon}
                    <span class="spell-cooldown">${cd > 0 ? cd + 's' : ''}</span>
                    <span class="spell-type">${MAGIC_TYPES[spell.magic].icon}</span>
                `;
                div.title = `${spell.name}: ${spell.desc}`;
                div.onclick = () => castSpell(spell);
                container.appendChild(div);
            });
        }

        function renderCreatureStatus() {
            const container = document.getElementById('creatureStatus');
            container.innerHTML = '';
            if (!currentCreature) return;

            currentCreature.abilities.forEach(ab => {
                const ability = ABILITIES[ab];
                if (ability) {
                    const div = document.createElement('div');
                    div.className = 'status-icon';
                    div.textContent = ability.icon;
                    div.title = ability.name;
                    container.appendChild(div);
                }
            });

            if (creatureBuffs.shield) {
                const div = document.createElement('div');
                div.className = 'status-icon';
                div.textContent = 'üõ°Ô∏è';
                container.appendChild(div);
            }
        }

        function renderBattleCreatureCard() {
            if (!currentCreature) {
                document.getElementById('battleCreatureCard').style.display = 'none';
                return;
            }

            const card = document.getElementById('battleCreatureCard');
            card.style.display = 'flex';

            // Draw creature sprite on canvas
            drawCreature();

            // Name (short version for display)
            const isBoss = currentCreature.boss;
            const nameEl = document.getElementById('battleCreatureName');
            const shortName = currentCreature.name.split(' ').pop(); // Last word of name
            nameEl.textContent = isBoss ? `üëë ${shortName}` : shortName;

            // HP bar
            const hpPercent = (creatureHp / currentCreature.maxHp) * 100;
            document.getElementById('creatureHealth').style.width = `${Math.max(0, hpPercent)}%`;
        }

        function updateBattleCreatureHp() {
            if (!currentCreature) return;

            const hpPercent = (creatureHp / currentCreature.maxHp) * 100;
            document.getElementById('creatureHealth').style.width = `${Math.max(0, hpPercent)}%`;
        }

        function generateRoom() {
            // Use floor number to seed randomness but add variation
            const seed = game.floor + game.roomSeed;
            const seededRandom = () => {
                const x = Math.sin(seed * 9999 + Math.random() * 100) * 10000;
                return x - Math.floor(x);
            };

            // Pick theme based on floor (with some randomness)
            const themeIndex = (game.floor + Math.floor(seededRandom() * 3)) % ROOM_THEMES.length;
            const theme = ROOM_THEMES[themeIndex];

            // Apply background
            const battleArea = document.getElementById('battleArea');
            const roomBg = document.getElementById('roomBackground');
            const roomGround = document.getElementById('roomGround');
            const magicParticles = document.getElementById('magicParticles');

            // Gradient background
            battleArea.style.background = `linear-gradient(180deg, ${theme.bg[0]} 0%, ${theme.bg[1]} 100%)`;
            roomGround.style.background = `linear-gradient(180deg, ${theme.ground} 0%, ${theme.bg[1]} 100%)`;

            // Magic particles/atmosphere
            const particleX1 = 20 + seededRandom() * 30;
            const particleX2 = 50 + seededRandom() * 30;
            magicParticles.style.background = `
                radial-gradient(circle at ${particleX1}% 40%, ${theme.particles} 0%, transparent 50%),
                radial-gradient(circle at ${particleX2}% 60%, ${theme.particles} 0%, transparent 50%)
            `;

            // Clear old decor
            document.querySelectorAll('.room-decor').forEach(el => el.remove());

            // Add random decorations
            const decorCount = 3 + Math.floor(seededRandom() * 3);
            for (let i = 0; i < decorCount; i++) {
                const decor = document.createElement('div');
                decor.className = 'room-decor';
                decor.textContent = theme.decor[Math.floor(seededRandom() * theme.decor.length)];
                decor.style.left = (5 + seededRandom() * 85) + '%';
                decor.style.top = (10 + seededRandom() * 50) + '%';
                decor.style.opacity = 0.3 + seededRandom() * 0.4;
                decor.style.fontSize = (12 + seededRandom() * 10) + 'px';
                decor.style.transform = `rotate(${seededRandom() * 30 - 15}deg)`;
                battleArea.appendChild(decor);
            }

            // Update room seed for next generation
            game.roomSeed = Math.floor(Math.random() * 10000);
        }

        function showRoomTransition(goldGain) {
            game.inBattle = false;
            game.lastGoldGain = goldGain;
            game.selectingBuff = true; // Freeze cooldowns while selecting

            const transition = document.getElementById('roomTransition');
            document.getElementById('roomLoot').textContent = `+${formatNum(goldGain)} Galleons`;
            document.getElementById('roomNext').textContent = `Room ${game.floor} awaits...`;

            transition.classList.add('active');

            // Show buff selection panel below game area
            document.getElementById('buffSelectionPanel').style.display = 'block';
            renderBuffChoices();

            playSound(600, 'sine', 0.15);
        }

        function getRandomBuffs(count = 3) {
            const roll = Math.random() * 100;
            let rarityPool;

            // Higher floors have better chances
            const floorBonus = Math.min(game.floor * 0.5, 15);

            if (roll < 2 + floorBonus * 0.1) rarityPool = 'legendary';
            else if (roll < 10 + floorBonus * 0.3) rarityPool = 'epic';
            else if (roll < 40 + floorBonus) rarityPool = 'rare';
            else rarityPool = 'common';

            // Filter buffs by rarity with some variety
            const available = BUFFS.filter(b => {
                // Skip spell unlocks for spells already learned
                if (b.effect.unlockSpell && game.unlockedSpells.includes(b.effect.unlockSpell)) return false;
                // Always include at least one from the rolled rarity
                if (b.rarity === rarityPool) return true;
                // Include lower rarities too
                if (rarityPool === 'legendary' && ['epic', 'rare'].includes(b.rarity)) return true;
                if (rarityPool === 'epic' && b.rarity === 'rare') return true;
                if (rarityPool === 'rare' && b.rarity === 'common') return true;
                return false;
            });

            // Shuffle and pick
            const shuffled = available.sort(() => Math.random() - 0.5);
            const choices = [];

            // Ensure variety - try to get different buffs
            for (const buff of shuffled) {
                if (choices.length >= count) break;
                // Avoid duplicates of same type if possible
                if (!choices.find(c => c.id === buff.id)) {
                    choices.push(buff);
                }
            }

            // Fill with any if not enough
            while (choices.length < count && shuffled.length > 0) {
                const buff = shuffled.pop();
                if (!choices.includes(buff)) choices.push(buff);
            }

            return choices;
        }

        function renderBuffChoices() {
            const container = document.getElementById('buffChoices');
            container.innerHTML = '';

            const choices = getRandomBuffs(2);

            choices.forEach(buff => {
                const div = document.createElement('div');
                div.className = 'buff-choice';
                div.innerHTML = `
                    <div class="buff-header">
                        <span class="buff-icon">${buff.icon}</span>
                        <span class="buff-name">${buff.name}</span>
                        <span class="buff-rarity ${buff.rarity}">${buff.rarity}</span>
                    </div>
                    <div class="buff-desc">${buff.desc}</div>
                    <div class="buff-stats">${buff.stats}</div>
                `;
                div.onclick = () => selectBuff(buff);
                container.appendChild(div);
            });
        }

        function selectBuff(buff) {
            // Add to active buffs
            game.activeBuffs.push({ id: buff.id, name: buff.name, icon: buff.icon });

            // Apply effect
            const effect = buff.effect;
            const bs = game.buffStats;

            if (effect.atk) bs.atk += effect.atk;
            if (effect.def) bs.def += effect.def;
            if (effect.hp) bs.hp += effect.hp;
            if (effect.crit) bs.crit += effect.crit;
            if (effect.critDmg) bs.critDmg += effect.critDmg;
            if (effect.goldBonus) bs.goldBonus += effect.goldBonus;
            if (effect.xpBonus) bs.xpBonus += effect.xpBonus;
            if (effect.lifesteal) bs.lifesteal += effect.lifesteal;
            if (effect.regenFlat) bs.regenFlat += effect.regenFlat;
            if (effect.dodge) bs.dodge += effect.dodge;
            if (effect.thorns) bs.thorns += effect.thorns;
            if (effect.executeDmg) bs.executeDmg += effect.executeDmg;
            if (effect.spellPower) bs.spellPower += effect.spellPower;
            if (effect.deathSaves) bs.deathSaves += effect.deathSaves;
            if (effect.doubleAttack) bs.doubleAttack = true;

            // Instant effects
            if (effect.healNow) {
                const stats = getStats();
                game.currentHp = Math.min(stats.hp, game.currentHp + effect.healNow);
                addLog(`Healed ${effect.healNow} HP!`, 'log-spell');
            }
            if (effect.fullHeal) {
                const stats = getStats();
                game.currentHp = stats.hp;
                addLog('Fully healed!', 'log-spell');
            }
            if (effect.goldNow) {
                game.gold += effect.goldNow;
                addLog(`+${effect.goldNow} Gold!`, 'log-gold');
            }
            if (effect.unlockSpell) {
                if (!game.unlockedSpells.includes(effect.unlockSpell)) {
                    game.unlockedSpells.push(effect.unlockSpell);
                    const spell = SPELLS.find(s => s.id === effect.unlockSpell);
                    addLog(`Learned ${spell ? spell.name : effect.unlockSpell}!`, 'log-spell');
                    renderSpellBar();
                }
            }

            // Update max HP if HP was added
            if (effect.hp) {
                const stats = getStats();
                game.maxHp = stats.hp;
                game.currentHp = Math.min(game.currentHp + effect.hp, stats.hp);
            }

            playSound(800, 'sine', 0.2);
            addLog(`Gained: ${buff.name}!`, 'log-levelup');

            renderActiveBuffs();
            updateUI();
            saveGame();

            // Continue to next room
            continueToNextRoom();
        }

        function renderActiveBuffs() {
            const container = document.getElementById('activeBuffs');
            container.innerHTML = '';

            // Count duplicate buffs
            const buffCounts = {};
            game.activeBuffs.forEach(b => {
                if (!buffCounts[b.id]) buffCounts[b.id] = { ...b, count: 0 };
                buffCounts[b.id].count++;
            });

            Object.values(buffCounts).forEach(buff => {
                const div = document.createElement('div');
                div.className = 'active-buff';
                div.title = buff.name;
                div.innerHTML = `
                    <span class="active-buff-icon">${buff.icon}</span>
                    ${buff.count > 1 ? `<span class="active-buff-count">x${buff.count}</span>` : ''}
                `;
                container.appendChild(div);
            });
        }

        function continueToNextRoom() {
            const transition = document.getElementById('roomTransition');
            transition.classList.remove('active');

            // Hide buff selection panel
            document.getElementById('buffSelectionPanel').style.display = 'none';

            // Unfreeze cooldowns
            game.selectingBuff = false;

            generateRoom();
            game.inBattle = true;
            spawnCreature();
        }

        // Load hero image
        const heroImage = new Image();
        heroImage.src = 'hero.png';

        function drawWizard() {
            heroCtx.clearRect(0, 0, 55, 75);
            if (heroImage.complete) {
                heroCtx.drawImage(heroImage, 0, 0, 55, 75);
            }
        }

        function drawCreature() {
            if (!currentCreature) return;
            creatureCtx.clearRect(0, 0, 50, 60);

            const magic = MAGIC_TYPES[currentCreature.magic];

            // Use sprite sheet if loaded and creature has sprite coordinates
            if (spriteSheetLoaded && currentCreature.spriteX !== undefined) {
                const srcX = currentCreature.spriteX * SPRITE_CELL + SPRITE_BORDER;
                const srcY = currentCreature.spriteY * SPRITE_CELL + SPRITE_BORDER;
                // Flip horizontally to face left (toward player)
                creatureCtx.save();
                creatureCtx.scale(-1, 1);
                creatureCtx.drawImage(
                    creatureSpriteSheet,
                    srcX, srcY, SPRITE_SIZE, SPRITE_SIZE,  // Source rectangle
                    -50, 0, 50, 60                          // Negative X for flip
                );
                creatureCtx.restore();
            } else {
                // Fallback to procedural drawing if sprite not available
                creatureCtx.fillStyle = magic.color;

                if (currentCreature.icon.includes('üßö') || currentCreature.icon.includes('ü™∞')) {
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(25, 40, 10, 8, 0, 0, Math.PI * 2);
                    creatureCtx.fill();
                    creatureCtx.fillStyle = 'rgba(255,255,255,0.5)';
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(15, 35, 8, 4, -0.5, 0, Math.PI * 2);
                    creatureCtx.ellipse(35, 35, 8, 4, 0.5, 0, Math.PI * 2);
                    creatureCtx.fill();
                } else if (currentCreature.icon.includes('üêâ') || currentCreature.icon.includes('üêç')) {
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(25, 38, 18, 14, 0, 0, Math.PI * 2);
                    creatureCtx.fill();
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(38, 25, 10, 8, 0.3, 0, Math.PI * 2);
                    creatureCtx.fill();
                    creatureCtx.fillStyle = '#ff0';
                    creatureCtx.fillRect(40, 22, 4, 4);
                } else if (currentCreature.icon.includes('üëª') || currentCreature.icon.includes('üë§')) {
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(25, 30, 15, 20, 0, 0, Math.PI * 2);
                    creatureCtx.fill();
                    creatureCtx.beginPath();
                    creatureCtx.moveTo(10, 45);
                    creatureCtx.quadraticCurveTo(17, 55, 25, 45);
                    creatureCtx.quadraticCurveTo(33, 55, 40, 45);
                    creatureCtx.fill();
                } else if (currentCreature.boss) {
                    creatureCtx.beginPath();
                    creatureCtx.ellipse(25, 32, 20, 18, 0, 0, Math.PI * 2);
                    creatureCtx.fill();
                    creatureCtx.fillStyle = '#ffd700';
                    creatureCtx.fillRect(15, 8, 20, 6);
                } else {
                    creatureCtx.fillRect(12, 22, 26, 26);
                    creatureCtx.beginPath();
                    creatureCtx.arc(25, 15, 12, 0, Math.PI * 2);
                    creatureCtx.fill();
                }

                creatureCtx.fillStyle = currentCreature.magic === 'DARK' ? '#ff0000' : '#fff';
                creatureCtx.fillRect(18, 12, 5, 5);
                creatureCtx.fillRect(28, 12, 5, 5);
            }

            document.getElementById('creatureMagic').textContent = magic.icon;
        }

        function calculateBalancedEnemy() {
            // Get player stats to balance enemy against
            const stats = getStats();

            // Calculate player's effective DPS (damage per turn)
            const avgCritMult = 1 + (stats.crit / 100) * stats.critDmg;
            const playerDPS = stats.atk * avgCritMult;

            // Calculate player's effective HP (considering defense, dodge, lifesteal, regen)
            const effectiveDefense = stats.def * 0.4; // Defense reduces ~40% of enemy atk
            const dodgeMultiplier = 1 - (stats.dodge / 100);
            const regenPerTurn = stats.regenFlat + (hasSkill('regen') ? stats.hp * 0.03 : 0);

            // Target: player should win consistently on first run
            // Enemy deals 30-50% of player HP before dying (reduced from 50-80%)
            // Player kills enemy in 5-8 turns

            const targetTurnsToKill = 5 + Math.random() * 3; // 5-8 turns to kill enemy
            const targetDamageToPlayer = stats.hp * (0.3 + Math.random() * 0.2); // Enemy deals 30-50% of player HP

            // Calculate enemy HP based on player DPS
            const enemyHP = Math.floor(playerDPS * targetTurnsToKill * (0.8 + Math.random() * 0.2));

            // Calculate enemy ATK: should deal targetDamageToPlayer over targetTurnsToKill turns
            // Accounting for player defense and dodge (reduced ATK scaling)
            const rawDamageNeeded = targetDamageToPlayer / targetTurnsToKill;
            const damageBeforeDefense = rawDamageNeeded / dodgeMultiplier;
            const enemyATK = Math.floor(damageBeforeDefense + effectiveDefense * 0.3);

            // Gold scales with difficulty
            const difficultyFactor = (enemyHP + enemyATK * 10) / 100;
            const enemyGold = Math.floor(10 + difficultyFactor * (1 + game.floor * 0.1));

            return { hp: enemyHP, atk: enemyATK, gold: enemyGold };
        }

        function spawnCreature() {
            turnCount = 0;
            creatureBuffs = {};
            game.fearDebuff = false;

            const isBoss = game.floor % 5 === 0;
            let template;

            if (isBoss) {
                const bossIdx = Math.min(Math.floor(game.floor / 5) - 1, BOSSES.length - 1);
                template = BOSSES[bossIdx];
                addLog(`‚ö†Ô∏è BOSS: ${template.name}!`, 'log-boss');
                playSound(200, 'sawtooth', 0.3);
            } else {
                const maxIdx = Math.min(Math.floor(game.floor / 3), CREATURES.length - 1);
                template = CREATURES[Math.floor(Math.random() * (maxIdx + 1))];
            }

            // Calculate balanced stats based on player power
            const balanced = calculateBalancedEnemy();

            // Boss multiplier (reduced for fair first-run experience)
            const bossHpMultiplier = isBoss ? 1.8 : 1;
            const bossAtkMultiplier = isBoss ? 1.4 : 1;

            // Minimum stats from template (reduced scaling for fair progression)
            const minHP = template.hp * (1 + game.floor * 0.02);
            const minATK = template.atk * (1 + game.floor * 0.015);

            currentCreature = {
                ...template,
                hp: Math.floor(Math.max(minHP, balanced.hp) * bossHpMultiplier),
                maxHp: Math.floor(Math.max(minHP, balanced.hp) * bossHpMultiplier),
                atk: Math.floor(Math.max(minATK, balanced.atk) * bossAtkMultiplier),
                gold: Math.floor(Math.max(template.gold, balanced.gold) * bossHpMultiplier)
            };
            creatureHp = currentCreature.hp;

            if (!game.discoveredCreatures.includes(template.name)) {
                game.discoveredCreatures.push(template.name);
                addLog(`New creature: ${template.name}!`, 'log-gold');
            }

            document.getElementById('creatureName').textContent = currentCreature.name;
            document.getElementById('creatureHealth').style.width = '100%';
            drawCreature();
            renderCreatureStatus();
            renderBattleCreatureCard();

            // Shield minigame for bosses is triggered from battle() via shouldTriggerShieldMinigame()
            // This ensures proper timing and avoids race conditions
        }

        function castSpell(spell) {
            if (!currentCreature || (game.spellCooldowns[spell.id] || 0) > 0) return;

            const stats = getStats();
            game.spellCooldowns[spell.id] = spell.cooldown;

            playSound(800, 'sine', 0.15);

            // Cast visual spell effect
            if (spell.heal || spell.shield) {
                castSpellVisual(spell, 60, 60); // On player
            } else {
                castSpellVisual(spell, 200, 60); // On enemy
            }
            spellEffect(220, 70, spell.color || MAGIC_TYPES[spell.magic].color);

            // Apply spell buff to player
            if (spell.buff) {
                game.combatBuffs.push({ ...spell.buff });
                addLog(`${spell.buff.type} buff for ${spell.buff.turns} turns!`, 'log-spell');
            }

            // Apply spell debuff to enemy
            if (spell.debuff) {
                if (spell.debuff.stacks) {
                    // Stackable debuffs add to existing
                    const existing = game.combatDebuffs.find(d => d.type === spell.debuff.type);
                    if (existing) {
                        existing.value += spell.debuff.value;
                        existing.turns = Math.max(existing.turns, spell.debuff.turns);
                    } else {
                        game.combatDebuffs.push({ ...spell.debuff });
                    }
                } else {
                    // Non-stackable refresh duration
                    const existing = game.combatDebuffs.find(d => d.type === spell.debuff.type);
                    if (existing) {
                        existing.turns = spell.debuff.turns;
                        if (spell.debuff.value) existing.value = spell.debuff.value;
                    } else {
                        game.combatDebuffs.push({ ...spell.debuff });
                    }
                }
                addLog(`Enemy ${spell.debuff.type}!`, 'log-effective');
            }

            // Instant heal from spell (like Herbivicus)
            if (spell.healNow) {
                game.currentHp = Math.min(stats.hp, game.currentHp + spell.healNow);
                showFloat(`+${spell.healNow}`, 60, 40, 'heal');
            }

            // Special effects
            if (spell.special === 'reduceCooldowns') {
                for (let key in game.spellCooldowns) {
                    if (game.spellCooldowns[key] > 0) {
                        game.spellCooldowns[key] = Math.max(0, game.spellCooldowns[key] - 2);
                    }
                }
                addLog('Cooldowns reduced by 2!', 'log-spell');
            }
            if (spell.special === 'cleanse') {
                game.combatDebuffs = game.combatDebuffs.filter(d => !['poison', 'burn', 'bleed'].includes(d.type));
                game.poisonStacks = 0;
                addLog('Cleansed negative effects!', 'log-spell');
            }
            if (spell.special === 'dispelFear') {
                game.fearDebuff = false;
                addLog('Fear dispelled!', 'log-spell');
            }

            if (spell.shield) {
                const shieldAmt = Math.floor(stats.hp * spell.shield);
                game.currentHp = Math.min(stats.hp, game.currentHp + shieldAmt);
                showFloat(`+${shieldAmt} Shield`, 60, 60, 'heal');
                createParticles(60, 80, '#88aaff', 8);
                addLog(`${spell.name}! Shield ${shieldAmt} HP`, 'log-spell');
            } else if (spell.heal) {
                const amt = Math.floor(stats.hp * spell.heal);
                game.currentHp = Math.min(stats.hp, game.currentHp + amt);
                showFloat(`+${amt}`, 60, 60, 'heal');
                createParticles(60, 80, spell.color || '#00ff00', 6);
                addLog(`${spell.name}! Healed ${amt} HP`, 'log-spell');
            } else {
                let damage = Math.floor(stats.atk * spell.damage);
                // Spell damage bonus from skills
                const spellBonus = getSkillEffect('spellDamage');
                if (spellBonus) damage = Math.floor(damage * (1 + spellBonus));
                // Spell power from buffs
                if (stats.spellPower > 0) damage = Math.floor(damage * (1 + stats.spellPower));

                // Combat buff bonuses
                const atkBuff = game.combatBuffs.filter(b => b.type === 'atk').reduce((sum, b) => sum + b.value, 0);
                if (atkBuff > 0) damage = Math.floor(damage * (1 + atkBuff));

                const critDmgBuff = game.combatBuffs.filter(b => b.type === 'critDmg').reduce((sum, b) => sum + b.value, 0);
                const critBuff = game.combatBuffs.filter(b => b.type === 'crit').reduce((sum, b) => sum + b.value, 0);
                const empowerBuff = game.combatBuffs.find(b => b.type === 'empower');
                if (empowerBuff) damage = Math.floor(damage * (1 + empowerBuff.value));

                const mult = getMagicMultiplier(spell.magic, currentCreature.magic);
                damage = Math.floor(damage * mult);

                // Special: percent damage (Bombarda)
                if (spell.special === 'percentDamage' && spell.percentDmg) {
                    const percentDmg = Math.floor(currentCreature.maxHp * spell.percentDmg);
                    damage += percentDmg;
                    addLog(`${spell.name} deals ${percentDmg} bonus damage!`, 'log-effective');
                }

                // Special: Avada Kedavra - instant kill but costs 50% of current HP
                if (spell.special === 'avadaKedavra') {
                    const hpCost = Math.floor(game.currentHp * 0.5);
                    game.currentHp -= hpCost;
                    showFloat(`-${hpCost}`, 60, 60, 'crit');
                    addLog(`Avada Kedavra costs ${hpCost} HP!`, 'log-boss');

                    // Instant kill the enemy
                    damage = creatureHp;
                    addLog('AVADA KEDAVRA!', 'log-boss');
                    showFloat('DEATH!', 220, 40, 'crit');

                    // Check if player died from HP cost
                    if (game.currentHp <= 0) {
                        if (stats.deathSaves > 0) {
                            game.buffStats.deathSaves--;
                            game.currentHp = Math.floor(stats.hp * 0.1);
                            addLog('Death saved! (' + (stats.deathSaves - 1) + ' left)', 'log-spell');
                        } else {
                            game.currentHp = 1; // Survive with 1 HP minimum from spell cost
                            addLog('Nearly killed yourself!', 'log-resist');
                        }
                    }
                }

                // Crit with buff bonus
                const totalCrit = stats.crit + critBuff;
                if (Math.random() * 100 < totalCrit) {
                    const totalCritDmg = stats.critDmg + critDmgBuff;
                    damage = Math.floor(damage * (1 + totalCritDmg));
                    showFloat(`CRIT -${damage}`, 220, 50, 'crit');
                } else {
                    const floatType = mult > 1 ? 'effective' : (mult < 1 ? 'resist' : 'spell');
                    showFloat(`-${damage}`, 220, 60, floatType);
                }

                if (mult > 1) addLog(`${spell.name} is super effective!`, 'log-effective');
                else if (mult < 1) addLog(`${spell.name} is not very effective...`, 'log-resist');

                creatureHp -= damage;

                // Lifesteal on spell damage too
                if (stats.lifesteal > 0) {
                    const healAmt = Math.floor(damage * stats.lifesteal);
                    if (healAmt > 0) game.currentHp = Math.min(stats.hp, game.currentHp + healAmt);
                }

                createParticles(220, 80, spell.color || MAGIC_TYPES[spell.magic].color, 8);
                battleArea.classList.add('shake');
                setTimeout(() => battleArea.classList.remove('shake'), 150);
            }

            checkCreatureDeath();
            updateUI();
            saveGame();
        }

        // Process debuffs on enemy each turn
        function processDebuffs() {
            let totalDot = 0;

            game.combatDebuffs.forEach(debuff => {
                if (debuff.type === 'poison' || debuff.type === 'burn' || debuff.type === 'bleed') {
                    totalDot += debuff.value;
                }
                if (debuff.type === 'hellfire') {
                    totalDot += debuff.burnValue;
                }
            });

            if (totalDot > 0) {
                creatureHp -= totalDot;
                showFloat(`-${totalDot}`, 220, 80, 'effective');
                addLog(`DoT deals ${totalDot} damage!`, 'log-effective');
            }

            // Decrement debuff turns
            game.combatDebuffs = game.combatDebuffs.filter(d => {
                d.turns--;
                return d.turns > 0;
            });
        }

        // Process buffs on player each turn
        function processBuffs() {
            // Regen buff
            const regenBuff = game.combatBuffs.filter(b => b.type === 'regen').reduce((sum, b) => sum + b.value, 0);
            if (regenBuff > 0) {
                const stats = getStats();
                game.currentHp = Math.min(stats.hp, game.currentHp + regenBuff);
                showFloat(`+${regenBuff}`, 60, 60, 'heal');
            }

            // Decrement buff turns
            game.combatBuffs = game.combatBuffs.filter(b => {
                b.turns--;
                return b.turns > 0;
            });
        }

        // Check if enemy is stunned
        function isEnemyStunned() {
            return game.combatDebuffs.some(d => d.type === 'stun' && d.turns > 0);
        }

        // Get enemy attack modifier from debuffs
        function getEnemyAtkMod() {
            let mod = 1;
            game.combatDebuffs.forEach(d => {
                if (d.type === 'weaken') mod -= d.value;
                if (d.type === 'torture') mod -= d.atkReduce;
            });
            return Math.max(0.1, mod);
        }

        // Get reflect damage from buffs
        function getReflectMod() {
            const reflect = game.combatBuffs.find(b => b.type === 'reflect');
            return reflect ? reflect.value : 0;
        }

        function processCreatureAbilities() {
            if (!currentCreature) return;

            currentCreature.abilities.forEach(ab => {
                switch(ab) {
                    case 'REGEN':
                        if (creatureHp < currentCreature.maxHp) {
                            const heal = Math.floor(currentCreature.maxHp * 0.05);
                            creatureHp = Math.min(currentCreature.maxHp, creatureHp + heal);
                            showFloat(`+${heal}`, 220, 50, 'heal');
                        }
                        break;
                    case 'SHIELD':
                        if (Math.random() < 0.25) creatureBuffs.shield = true;
                        break;
                    case 'RAGE':
                        if (creatureHp < currentCreature.maxHp * 0.3) creatureBuffs.enraged = true;
                        break;
                    case 'POISON':
                        if (Math.random() < 0.3) {
                            game.poisonStacks = Math.min(5, game.poisonStacks + 1);
                            addLog('Poisoned!', 'log-damage');
                        }
                        break;
                    case 'FEAR':
                        if (Math.random() < 0.2 && !hasSkill('fearImmune')) {
                            game.fearDebuff = true;
                            addLog('Terrified! Attack reduced!', 'log-damage');
                        }
                        break;
                }
            });

            if (game.poisonStacks > 0) {
                const dmg = Math.floor(game.maxHp * 0.02 * game.poisonStacks);
                game.currentHp -= dmg;
                showFloat(`-${dmg} ‚ò†Ô∏è`, 60, 50);
            }

            renderCreatureStatus();
        }

        function battle() {
            // Don't battle if not in battle mode (waiting at room transition)
            if (!game.inBattle) return;

            if (!currentCreature) {
                spawnCreature();
                return;
            }

            turnCount++;
            const stats = getStats();

            // Player attacks
            const isCrit = Math.random() * 100 < stats.crit;
            let damage = Math.max(1, stats.atk - Math.floor(currentCreature.atk * 0.08));

            const mult = getMagicMultiplier(stats.wandMagic, currentCreature.magic);
            damage = Math.floor(damage * mult);

            // Crit damage multiplier from buffs
            if (isCrit) damage = Math.floor(damage * (1 + stats.critDmg));

            // Execute damage bonus (buff)
            if (stats.executeDmg > 0 && creatureHp < currentCreature.maxHp * 0.3) {
                damage = Math.floor(damage * (1 + stats.executeDmg));
            }

            // Creature shield
            if (creatureBuffs.shield) {
                damage = Math.floor(damage * 0.5);
                creatureBuffs.shield = false;
            }

            // Double attack buff
            if (stats.doubleAttack) {
                damage = Math.floor(damage * 2);
            }

            // Dodge
            if (currentCreature.abilities.includes('DODGE') && Math.random() < 0.15) {
                showFloat('MISS', 220, 60, 'resist');
            } else {
                // Execute skill
                if (hasSkill('execute') && creatureHp < currentCreature.maxHp * 0.15) {
                    damage = creatureHp;
                    addLog('Avada Kedavra!', 'log-crit');
                }

                creatureHp -= damage;
                const floatType = isCrit ? 'crit' : (mult > 1 ? 'effective' : '');
                showFloat(`${isCrit ? 'CRIT ' : ''}-${damage}`, 220, 60, floatType);
                playSound(isCrit ? 600 : 400, isCrit ? 'sawtooth' : 'square', 0.08);

                // Lifesteal
                if (stats.lifesteal > 0) {
                    const healAmt = Math.floor(damage * stats.lifesteal);
                    if (healAmt > 0) {
                        game.currentHp = Math.min(stats.hp, game.currentHp + healAmt);
                        showFloat(`+${healAmt}`, 80, 50, 'heal');
                    }
                }
            }

            // Animations
            heroCanvas.classList.add('attacking');
            setTimeout(() => heroCanvas.classList.remove('attacking'), 100);
            setTimeout(() => {
                creatureCanvas.classList.add('hit');
                setTimeout(() => creatureCanvas.classList.remove('hit'), 100);
            }, 100);

            document.getElementById('creatureHealth').style.width = `${Math.max(0, (creatureHp / currentCreature.maxHp) * 100)}%`;
            updateBattleCreatureHp();

            if (creatureHp <= 0) {
                checkCreatureDeath();
            } else {
                // Check if boss shield minigame should trigger
                if (shouldTriggerShieldMinigame()) {
                    startShieldMinigame();
                    updateUI();
                    return; // Pause battle for minigame
                }

                // Process spell debuffs on enemy (DoT, etc)
                processDebuffs();

                // Check if enemy died from DoT
                if (creatureHp <= 0) {
                    checkCreatureDeath();
                    updateUI();
                    return;
                }

                // Process player buffs (regen, etc)
                processBuffs();

                processCreatureAbilities();

                // Check if enemy is stunned (skip their turn)
                if (isEnemyStunned()) {
                    addLog('Enemy is stunned!', 'log-spell');
                    showFloat('STUNNED', 220, 50, 'spell');
                } else {
                    // Player dodge chance from buffs
                    if (stats.dodge > 0 && Math.random() * 100 < stats.dodge) {
                        showFloat('DODGE!', 60, 50, 'spell');
                    } else {
                        let creatureDmg = Math.max(1, currentCreature.atk - Math.floor(stats.def * 0.4));
                        creatureDmg = Math.floor(creatureDmg * (1 - stats.dmgReduce));
                        if (creatureBuffs.enraged) creatureDmg = Math.floor(creatureDmg * 1.5);

                        // Apply enemy debuffs (weaken, torture)
                        creatureDmg = Math.floor(creatureDmg * getEnemyAtkMod());

                        // Thorns damage
                        if (stats.thorns > 0) {
                            const thornsDmg = Math.floor(creatureDmg * stats.thorns);
                            creatureHp -= thornsDmg;
                            showFloat(`-${thornsDmg}üåπ`, 220, 40);
                        }

                        // Reflect from spell buff (Protego)
                        const reflectMod = getReflectMod();
                        if (reflectMod > 0) {
                            const reflectDmg = Math.floor(creatureDmg * reflectMod);
                            creatureHp -= reflectDmg;
                            showFloat(`-${reflectDmg}üõ°Ô∏è`, 220, 30, 'spell');
                        }

                        // Reflect from creature ability
                        if (currentCreature.abilities.includes('REFLECT')) {
                            const reflectDmg = Math.floor(damage * 0.2);
                            game.currentHp -= reflectDmg;
                            showFloat(`-${reflectDmg}`, 100, 50);
                        }

                        game.currentHp -= creatureDmg;
                        showFloat(`-${creatureDmg}`, 60, 60);
                    }
                }

                // Regen from buffs (flat)
                if (stats.regenFlat > 0) {
                    game.currentHp = Math.min(stats.hp, game.currentHp + stats.regenFlat);
                }

                // Regen skill (percentage)
                if (hasSkill('regen')) {
                    const regenAmt = Math.floor(stats.hp * 0.03);
                    game.currentHp = Math.min(stats.hp, game.currentHp + regenAmt);
                }

                if (game.currentHp <= 0) {
                    // Death saves from buffs
                    if (stats.deathSaves > 0) {
                        game.buffStats.deathSaves--;
                        game.currentHp = Math.floor(stats.hp * 0.3);
                        addLog('Death saved! (' + stats.deathSaves + ' left)', 'log-spell');
                    } else if (hasSkill('felix') && !game.felixUsed) {
                        game.currentHp = Math.floor(stats.hp * 0.3);
                        game.felixUsed = true;
                        addLog('Felix Felicis saved you!', 'log-spell');
                    } else {
                        // Game Over!
                        gameOver();
                        return;
                    }
                }
            }

            updateUI();
            saveGame();
        }

        function checkCreatureDeath() {
            if (creatureHp <= 0 && currentCreature) {
                const stats = getStats();
                let goldGain = currentCreature.gold;
                // Gold bonus from skills
                const goldBonus = getSkillEffect('goldBonus');
                if (goldBonus) goldGain = Math.floor(goldGain * (1 + goldBonus));
                // Gold bonus from buffs
                if (stats.goldBonus > 0) goldGain = Math.floor(goldGain * (1 + stats.goldBonus));

                game.gold += goldGain;
                game.totalGoldEarned += goldGain;
                game.runGold += goldGain;
                game.totalKills++;
                game.runKills++;
                game.combo++;
                if (game.combo > game.maxCombo) game.maxCombo = game.combo;
                game.poisonStacks = Math.max(0, game.poisonStacks - 1);
                game.fearDebuff = false;

                // Restore 15% HP after each victory
                const hpRestore = Math.floor(stats.hp * 0.15);
                game.currentHp = Math.min(stats.hp, game.currentHp + hpRestore);
                if (hpRestore > 0) {
                    showFloat(`+${hpRestore} HP`, 60, 40, 'heal');
                }

                // Reset combat buffs/debuffs for next fight
                game.combatBuffs = [];
                game.combatDebuffs = [];

                let expGain = 10 + game.floor * 5;
                if (stats.xpBonus) expGain = Math.floor(expGain * (1 + stats.xpBonus));
                game.exp += expGain;
                if (game.exp >= game.expToLevel) {
                    game.level++;
                    game.exp -= game.expToLevel;
                    game.expToLevel = Math.floor(game.expToLevel * 1.25);
                    game.skillPoints++;
                    game.currentHp = getStats().hp;
                    addLog(`Year ${game.level}! +1 Study Point!`, 'log-levelup');
                    playSound(1000, 'sine', 0.2);
                }

                if (Math.random() < 0.04 + (currentCreature.boss ? 0.25 : 0)) {
                    game.gems++;
                    addLog('Found a Sickle!', 'log-gold');
                }

                showFloat(`+${goldGain}`, 220, 40, 'gold');
                createParticles(220, 80, MAGIC_TYPES[currentCreature.magic].color, 6);

                game.floor++;
                currentCreature = null;
                game.inBattle = false; // Stop battle loop during transition
                updateUI();
                saveGame();

                // Show room transition instead of immediately spawning
                setTimeout(() => showRoomTransition(goldGain), 400);
            }
        }

        function renderShop() {
            const container = document.getElementById('shopItems');
            container.innerHTML = '';

            SHOP_ITEMS.forEach(item => {
                // Skip house relics that don't belong to player's house
                if (item.house && item.house !== game.house) return;

                const owned = game.owned.includes(item.id);
                const equipped = game.equipment[item.type] === item.id;
                const canAfford = game.gold >= item.price;
                const isRelic = item.type === 'relic';

                const div = document.createElement('div');
                div.className = `shop-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''} ${!owned && !canAfford && !isRelic ? 'locked' : ''}`;

                let stats = '';
                if (item.atk) stats += `+${item.atk} MAG `;
                if (item.def) stats += `+${item.def} SHD `;
                if (item.hp) stats += `+${item.hp} HP `;
                if (item.crit) stats += `+${item.crit}% CRT`;
                if (item.xpBonus) stats += `+${Math.floor(item.xpBonus * 100)}% XP`;

                div.innerHTML = `
                    <div class="item-icon">${item.icon}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-stat">${stats}</div>
                    ${item.magic ? `<div class="item-magic">${MAGIC_TYPES[item.magic].icon} ${MAGIC_TYPES[item.magic].name}</div>` : ''}
                    <div class="item-price">${owned ? (equipped ? '‚úì Equipped' : 'Equip') : (isRelic ? 'House Relic' : item.price + ' G')}</div>
                `;

                div.onclick = () => {
                    if (owned) {
                        game.equipment[item.type] = item.id;
                        playSound(600, 'sine', 0.1);
                    } else if (canAfford && !isRelic) {
                        game.gold -= item.price;
                        game.owned.push(item.id);
                        game.equipment[item.type] = item.id;
                        playSound(800, 'sine', 0.15);
                    }
                    drawWizard();
                    renderShop();
                    updateUI();
                    saveGame();
                };

                container.appendChild(div);
            });
        }

        function renderSkillTree() {
            const container = document.getElementById('treePaths');
            container.innerHTML = '';

            for (const [key, tree] of Object.entries(SKILL_TREES)) {
                const pathDiv = document.createElement('div');
                pathDiv.className = 'tree-path';
                pathDiv.innerHTML = `
                    <div class="path-header">
                        <div class="path-icon">${tree.icon}</div>
                        <div class="path-name" style="color:${tree.color}">${tree.name}</div>
                    </div>
                    <div class="tree-skills" id="tree-${key}"></div>
                `;
                container.appendChild(pathDiv);

                const skillsDiv = pathDiv.querySelector('.tree-skills');
                tree.skills.forEach(skill => {
                    const unlocked = game.unlockedSkills.includes(skill.id);
                    const hasReq = !skill.requires || game.unlockedSkills.includes(skill.requires);
                    const canAfford = game.skillPoints >= skill.cost;
                    const available = !unlocked && hasReq && canAfford;

                    const skillDiv = document.createElement('div');
                    skillDiv.className = `tree-skill ${unlocked ? 'unlocked' : ''} ${available ? 'available' : ''} ${!unlocked && !hasReq ? 'locked' : ''}`;
                    skillDiv.innerHTML = `
                        <div class="tree-skill-header">
                            <span class="tree-skill-icon">${skill.icon}</span>
                            <span class="tree-skill-name">${skill.name}</span>
                            <span class="tree-skill-cost">${unlocked ? '‚úì' : skill.cost}</span>
                        </div>
                        <div class="tree-skill-desc">${skill.desc}</div>
                    `;

                    // Always add click handler - check conditions at click time
                    skillDiv.onclick = () => {
                        const isUnlocked = game.unlockedSkills.includes(skill.id);
                        const meetsReq = !skill.requires || game.unlockedSkills.includes(skill.requires);
                        const affordable = game.skillPoints >= skill.cost;

                        if (isUnlocked) {
                            addLog(`Already learned ${skill.name}!`, 'log-spell');
                            return;
                        }

                        if (!meetsReq) {
                            addLog(`Requires previous skill first!`, 'log-resist');
                            playSound(300, 'square', 0.1);
                            return;
                        }

                        if (!affordable) {
                            addLog(`Need ${skill.cost} Study Points! (Have ${game.skillPoints})`, 'log-resist');
                            playSound(300, 'square', 0.1);
                            return;
                        }

                        // Unlock the skill
                        game.skillPoints -= skill.cost;
                        game.unlockedSkills.push(skill.id);
                        playSound(1000, 'sine', 0.15);
                        addLog(`Learned ${skill.name}!`, 'log-levelup');
                        renderSkillTree();
                        renderSpellBar();
                        updateUI();
                        saveGame();
                    };

                    skillsDiv.appendChild(skillDiv);
                });
            }
        }

        function renderBestiary() {
            const container = document.getElementById('bestiaryList');
            container.innerHTML = '';

            [...CREATURES, ...BOSSES].forEach(creature => {
                const discovered = game.discoveredCreatures.includes(creature.name);
                const div = document.createElement('div');
                div.className = `creature-entry ${!discovered ? 'unknown' : ''}`;

                const magic = MAGIC_TYPES[creature.magic];
                const weakTo = MAGIC_TYPES[magic.weakTo];

                // Create icon container
                const iconDiv = document.createElement('div');
                iconDiv.className = 'creature-icon';

                if (discovered && spriteSheetLoaded && creature.spriteX !== undefined) {
                    // Use canvas sprite for discovered creatures
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 48;
                    canvas.style.width = '40px';
                    canvas.style.height = '48px';
                    const ctx = canvas.getContext('2d');

                    const srcX = creature.spriteX * SPRITE_CELL + SPRITE_BORDER;
                    const srcY = creature.spriteY * SPRITE_CELL + SPRITE_BORDER;
                    ctx.drawImage(
                        creatureSpriteSheet,
                        srcX, srcY, SPRITE_SIZE, SPRITE_SIZE,
                        0, 0, 40, 48
                    );
                    iconDiv.appendChild(canvas);
                } else {
                    iconDiv.textContent = discovered ? creature.icon : '‚ùì';
                }

                // Create info container
                const infoDiv = document.createElement('div');
                infoDiv.className = 'creature-info';
                infoDiv.innerHTML = `
                    <div class="creature-title">
                        ${discovered ? creature.name : '???'}
                        ${discovered ? magic.icon : ''}
                        ${creature.boss ? 'üëë' : ''}
                    </div>
                    ${discovered ? `
                        <div class="creature-stats">HP: ${creature.hp} | ATK: ${creature.atk}</div>
                        <div class="creature-weakness">Weak to: ${weakTo ? weakTo.icon + ' ' + weakTo.name : 'None'}</div>
                        ${creature.abilities.length ? `<div class="creature-ability">Traits: ${creature.abilities.map(a => ABILITIES[a]?.icon || a).join(' ')}</div>` : ''}
                    ` : '<div class="creature-stats">Defeat to discover</div>'}
                `;

                div.appendChild(iconDiv);
                div.appendChild(infoDiv);
                container.appendChild(div);
            });
        }

        function renderSpellbook() {
            const container = document.getElementById('spellbookList');
            container.innerHTML = '';

            SPELLS.forEach(spell => {
                const isUnlocked = game.unlockedSpells.includes(spell.id);
                const magic = MAGIC_TYPES[spell.magic];

                const div = document.createElement('div');
                div.className = `spell-entry ${isUnlocked ? 'unlocked' : 'locked'}`;

                div.innerHTML = `
                    <div class="spell-entry-icon" style="color: ${spell.color}">${spell.icon}</div>
                    <div class="spell-entry-info">
                        <div class="spell-entry-name">
                            ${spell.name}
                            <span class="spell-entry-magic" style="background: ${magic.color}20; color: ${magic.color}">${magic.icon} ${magic.name}</span>
                        </div>
                        <div class="spell-entry-desc">${spell.desc}</div>
                        <div class="spell-entry-cooldown">‚è±Ô∏è Cooldown: ${spell.cooldown}s${spell.damage > 0 ? ` | üí• Damage: ${spell.damage}x` : ''}${spell.heal ? ` | üíö Heal: ${Math.floor(spell.heal * 100)}%` : ''}${spell.shield ? ` | üõ°Ô∏è Shield: ${Math.floor(spell.shield * 100)}%` : ''}</div>
                    </div>
                    <div class="spell-entry-status ${isUnlocked ? 'unlocked' : 'locked'}">${isUnlocked ? '‚úì Learned' : 'üîí Locked'}</div>
                `;

                container.appendChild(div);
            });
        }

        function gameOver() {
            game.gameStarted = false;
            if (game.floor > game.bestFloor) game.bestFloor = game.floor;

            document.getElementById('gameoverFloor').textContent = `Reached Floor ${game.floor}`;
            document.getElementById('gameoverKills').textContent = game.runKills;
            document.getElementById('gameoverGold').textContent = formatNum(game.runGold);
            document.getElementById('gameoverCombo').textContent = game.maxCombo;
            document.getElementById('gameoverPopup').style.display = 'flex';

            playSound(150, 'sawtooth', 0.3);
            saveGame();
        }

        function restartGame() {
            // Full reset - same as page reload
            game.gold = 0;
            game.gems = 0;
            game.level = 1;
            game.floor = 1;
            game.exp = 0;
            game.expToLevel = 100;
            game.currentHp = 100;
            game.bestFloor = 0;
            game.totalKills = 0;
            game.totalGoldEarned = 0;
            game.discoveredCreatures = [];
            game.equipment = { wand: null, robe: null, amulet: null, book: null, relic: null };
            game.owned = [];
            game.skillPoints = 0;
            game.unlockedSkills = [];
            game.combo = 0;
            game.maxCombo = 0;
            game.spellCooldowns = {};
            game.poisonStacks = 0;
            game.fearDebuff = false;
            game.felixUsed = false;
            game.runKills = 0;
            game.runGold = 0;
            game.houseChosen = false;
            game.house = null;
            game.gameStarted = false;
            game.inBattle = false;
            game.selectingBuff = false;
            game.roomSeed = 0;
            game.lastGoldGain = 0;
            // Reset combat buffs/debuffs
            game.combatBuffs = [];
            game.combatDebuffs = [];
            // Reset spells - will be set by house selection
            game.unlockedSpells = [];
            // Reset roguelike buffs
            game.activeBuffs = [];
            game.buffStats = { atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0, goldBonus: 0, xpBonus: 0, lifesteal: 0, regenFlat: 0, dodge: 0, thorns: 0, executeDmg: 0, spellPower: 0, deathSaves: 0, doubleAttack: false };

            // Reset tutorials - start fresh like page reload
            game.spellTutorialDone = false;
            game.shieldTutorialDone = false;

            // Reset global combat state
            currentCreature = null;
            creatureHp = 0;
            creatureBuffs = {};
            turnCount = 0;

            // Reset shield minigame state
            shieldGame = {
                active: false,
                currentColor: null,
                timeLeft: 0,
                timerInterval: null,
                isTutorial: false,
                bossSpellQueue: [],
                spellsBlocked: 0,
                spellsMissed: 0,
                tutorialShown: false
            };

            // Hide all popups and overlays
            document.getElementById('gameoverPopup').style.display = 'none';
            document.getElementById('buffSelectionPanel').style.display = 'none';
            document.getElementById('shieldMinigame').classList.remove('active');
            document.getElementById('shieldTutorialOverlay').style.display = 'none';
            document.getElementById('spellTutorialOverlay').style.display = 'none';
            document.getElementById('roomTransition').classList.remove('active');

            // Clear any running timers
            if (shieldGame.timerInterval) {
                clearInterval(shieldGame.timerInterval);
            }

            renderActiveBuffs();
            updateUI();

            // Show house selection again
            showHouseSelection();
            saveGame();
        }

        function showHouseSelection() {
            document.getElementById('houseSelectPopup').style.display = 'flex';
        }

        function updateHouseDisplay() {
            const houseIcons = {
                gryffindor: 'ü¶Å',
                slytherin: 'üêç',
                ravenclaw: 'ü¶Ö',
                hufflepuff: 'ü¶°'
            };
            const houseNames = {
                gryffindor: 'Gryffindor',
                slytherin: 'Slytherin',
                ravenclaw: 'Ravenclaw',
                hufflepuff: 'Hufflepuff'
            };
            if (game.house) {
                document.getElementById('currentHouseIcon').textContent = houseIcons[game.house];
                document.getElementById('currentHouseName').textContent = houseNames[game.house];
            }
        }

        function selectHouse(house) {
            game.house = house;
            game.houseChosen = true;
            game.runKills = 0;
            game.runGold = 0;
            game.roomSeed = Math.floor(Math.random() * 10000);
            // Reset roguelike buffs for new run
            game.activeBuffs = [];
            game.buffStats = { atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0, goldBonus: 0, xpBonus: 0, lifesteal: 0, regenFlat: 0, dodge: 0, thorns: 0, executeDmg: 0, spellPower: 0, deathSaves: 0, doubleAttack: false };

            // Give house-specific relic
            const relicMap = {
                gryffindor: 'gryffindor_sword',
                slytherin: 'slytherin_locket',
                ravenclaw: 'ravenclaw_diadem',
                hufflepuff: 'hufflepuff_cup'
            };
            const relicId = relicMap[house];
            game.owned.push(relicId);
            game.equipment.relic = relicId;

            // Give house-specific starting spell
            const spellMap = {
                gryffindor: 'expelliarmus',
                slytherin: 'serpensortia',
                ravenclaw: 'lumos',
                hufflepuff: 'herbivicus'
            };
            game.unlockedSpells = [spellMap[house]];

            // Update house display
            updateHouseDisplay();

            document.getElementById('houseSelectPopup').style.display = 'none';

            const stats = getStats();
            game.currentHp = stats.hp;
            game.maxHp = stats.hp;

            generateRoom();
            drawWizard();
            renderShop();
            renderSkillTree();
            renderBestiary();
            renderActiveBuffs();
            renderSpellBar();
            updateUI();
            spawnCreature();
            saveGame();

            addLog(`Welcome to ${house.charAt(0).toUpperCase() + house.slice(1)}!`, 'log-levelup');

            // Show spell tutorial for first-time players
            if (!game.spellTutorialDone) {
                showSpellTutorial();
            } else {
                // Tutorial already done, start battle immediately
                game.gameStarted = true;
                game.inBattle = true;
                startBattle();
            }
        }

        function calculateOffline() {
            const elapsed = Math.floor((Date.now() - game.lastOnline) / 1000);
            const seconds = Math.min(elapsed, 8 * 60 * 60);
            if (seconds < 60) return null;
            return { gold: Math.floor(seconds * 0.3 * (5 + game.floor * 2)) };
        }

        function showOffline(rewards) {
            document.getElementById('offlineGold').textContent = `+${formatNum(rewards.gold)} Galleons`;
            document.getElementById('offlinePopup').style.display = 'flex';
            document.getElementById('offlineClaimBtn').onclick = () => {
                game.gold += rewards.gold;
                game.totalGoldEarned += rewards.gold;
                document.getElementById('offlinePopup').style.display = 'none';
                updateUI();
                saveGame();
            };
        }

        function saveGame() {
            game.lastOnline = Date.now();
            localStorage.setItem('wizardDuels', JSON.stringify(game));
        }

        let battleInterval = null;

        function init() {
            // House selection popup event listeners
            document.querySelectorAll('.house-option').forEach(opt => {
                opt.addEventListener('click', () => selectHouse(opt.dataset.house));
            });

            // Game over retry button
            document.getElementById('gameoverRetryBtn').addEventListener('click', restartGame);

            // Check if this is a new game or continuing
            if (!game.houseChosen || !game.gameStarted) {
                showHouseSelection();
            } else {
                // Continuing existing game
                const offline = calculateOffline();
                if (offline) showOffline(offline);

                game.inBattle = true;
                updateHouseDisplay();
                generateRoom();
                updateUI();
                renderShop();
                renderSkillTree();
                renderBestiary();
                renderActiveBuffs();
                drawWizard();
                spawnCreature();
                startBattle();
            }

            // Cooldown timer always runs (but freezes during buff selection)
            setInterval(() => {
                // Don't tick cooldowns while selecting buffs
                if (game.selectingBuff) return;
                for (const id in game.spellCooldowns) {
                    if (game.spellCooldowns[id] > 0) game.spellCooldowns[id]--;
                }
                renderSpellBar();
            }, 1000);
            setInterval(saveGame, 10000);
        }

        function startBattle() {
            if (battleInterval) clearInterval(battleInterval);
            battleInterval = setInterval(() => {
                if (game.gameStarted && !shieldGame.active) battle();
            }, 900);
        }

        // ============ BOSS SHIELD MINIGAME ============

        function isFirstBossEver() {
            // First boss is floor 5, check if player has beaten any boss before
            return game.floor === 5 && game.bestFloor < 5;
        }

        function startShieldMinigame() {
            // Only show tutorial on the FIRST shield phase of the first boss ever
            // Use game.shieldTutorialDone to track if we've shown it (persists across phases)
            const isFirstPhase = !creatureBuffs.shieldPhase2; // Phase 1 if phase 2 hasn't triggered yet
            const shouldShowTutorial = isFirstBossEver() && isFirstPhase && !game.shieldTutorialDone;

            shieldGame = {
                active: true,
                currentColor: null,
                timeLeft: 0,
                timerInterval: null,
                isTutorial: shouldShowTutorial,
                bossSpellQueue: generateBossSpells(shouldShowTutorial ? 3 : 5),
                spellsBlocked: 0,
                spellsMissed: 0,
                tutorialShown: false
            };

            // Set boss icon
            if (currentCreature) {
                document.getElementById('shieldEnemyIcon').textContent = currentCreature.icon;
            }

            // For tutorial, show the explanation overlay first
            if (shouldShowTutorial && !shieldGame.tutorialShown) {
                showTutorialOverlay();
                return;
            }

            beginShieldMinigame();
        }

        function showTutorialOverlay() {
            document.getElementById('shieldTutorialOverlay').style.display = 'flex';
            playSound(500, 'sine', 0.2);

            document.getElementById('shieldTutorialStartBtn').onclick = () => {
                document.getElementById('shieldTutorialOverlay').style.display = 'none';
                shieldGame.tutorialShown = true;
                game.shieldTutorialDone = true; // Mark tutorial as done permanently
                beginShieldMinigame();
            };
        }

        // ============ SPELL TUTORIAL (Beginning of game) ============

        let spellTutorialPage = 1;

        function showSpellTutorial() {
            if (game.spellTutorialDone) return;

            spellTutorialPage = 1;
            updateSpellTutorialPages();
            document.getElementById('spellTutorialOverlay').style.display = 'flex';
            playSound(600, 'sine', 0.2);
        }

        function nextSpellTutorialPage() {
            spellTutorialPage++;
            updateSpellTutorialPages();
            playSound(500, 'sine', 0.1);
        }

        function updateSpellTutorialPages() {
            for (let i = 1; i <= 3; i++) {
                const page = document.getElementById(`spellTutorialPage${i}`);
                if (page) {
                    page.classList.toggle('active', i === spellTutorialPage);
                }
            }
        }

        function finishSpellTutorial() {
            game.spellTutorialDone = true;
            document.getElementById('spellTutorialOverlay').style.display = 'none';
            playSound(800, 'sine', 0.2);
            saveGame();

            // Now start the actual game
            game.gameStarted = true;
            game.inBattle = true;
            startBattle();
            addLog('Your adventure begins!', 'log-levelup');
        }

        function beginShieldMinigame() {
            document.getElementById('shieldMinigame').classList.add('active');
            document.getElementById('shieldResult').textContent = '';
            document.getElementById('shieldResult').className = 'shield-result';

            // Reset incoming area with player/enemy icons
            document.getElementById('shieldIncoming').innerHTML = `
                <span class="shield-player-icon">üßô</span>
                <span class="shield-enemy-icon">${currentCreature ? currentCreature.icon : 'üßå'}</span>
            `;

            if (shieldGame.isTutorial) {
                document.getElementById('shieldTitle').textContent = 'üõ°Ô∏è TUTORIAL: Tap the glowing button!';
                document.getElementById('shieldHint').textContent = 'Watch the spell color and tap the matching shield!';
                document.getElementById('shieldTimerBar').classList.add('tutorial');
            } else {
                document.getElementById('shieldTitle').textContent = 'üõ°Ô∏è Block the incoming spells!';
                document.getElementById('shieldHint').textContent = '';
                document.getElementById('shieldTimerBar').classList.remove('tutorial');
            }

            addLog('üõ°Ô∏è Boss casting spells! Block them!', 'log-boss');
            playSound(400, 'sine', 0.2);

            // Setup shield button listeners
            document.querySelectorAll('.shield-btn').forEach(btn => {
                btn.onclick = () => handleShieldPress(btn.dataset.color);
            });

            // Brief delay before first spell
            setTimeout(() => {
                if (shieldGame.active) sendNextBossSpell();
            }, shieldGame.isTutorial ? 1000 : 500);
        }

        function generateBossSpells(count) {
            const colors = ['red', 'blue', 'yellow', 'green'];
            const spells = [];
            for (let i = 0; i < count; i++) {
                spells.push(colors[Math.floor(Math.random() * colors.length)]);
            }
            return spells;
        }

        function sendNextBossSpell() {
            if (shieldGame.bossSpellQueue.length === 0) {
                endShieldMinigame();
                return;
            }

            const color = shieldGame.bossSpellQueue.shift();
            shieldGame.currentColor = color;

            // Time to react - tutorial is MUCH slower (4 seconds)
            const baseTime = shieldGame.isTutorial ? 4000 : 1500;
            // Gets faster with each boss (floor 5, 10, 15, etc.)
            const speedBonus = shieldGame.isTutorial ? 0 : Math.min((game.floor / 5 - 1) * 100, 600);
            shieldGame.timeLeft = baseTime - speedBonus;

            // Show incoming spell flying toward player
            const incomingDiv = document.getElementById('shieldIncoming');
            const spellData = SHIELD_COLORS[color];
            incomingDiv.innerHTML = `
                <span class="shield-player-icon">üßô</span>
                <span class="shield-spell flying ${shieldGame.isTutorial ? 'tutorial' : ''}" style="color: ${getShieldColor(color)}">${spellData.spellIcon}</span>
                <span class="shield-enemy-icon">${currentCreature ? currentCreature.icon : 'üßå'}</span>
            `;

            // Update hint for tutorial
            if (shieldGame.isTutorial) {
                const colorName = SHIELD_COLORS[color].name;
                document.getElementById('shieldHint').innerHTML = `<b style="color: ${getShieldColor(color)}">${colorName}</b> spell incoming! Tap the <b style="color: ${getShieldColor(color)}">${spellData.icon}</b> button!`;
            }

            // Clear previous highlights
            document.querySelectorAll('.shield-btn').forEach(btn => btn.classList.remove('highlight'));

            // In tutorial, highlight the correct button
            if (shieldGame.isTutorial) {
                document.querySelector(`.shield-btn.${color}`).classList.add('highlight');
            }

            // Start timer
            updateShieldTimer();
            shieldGame.timerInterval = setInterval(() => {
                shieldGame.timeLeft -= 100;
                updateShieldTimer();

                if (shieldGame.timeLeft <= 0) {
                    // Time's up - failed to block
                    clearInterval(shieldGame.timerInterval);
                    shieldMiss();
                }
            }, 100);

            playSound(600 + (color === 'red' ? 0 : color === 'blue' ? 100 : color === 'yellow' ? 200 : 300), 'sine', 0.15);
        }

        function getShieldColor(color) {
            switch(color) {
                case 'red': return '#ff4444';
                case 'blue': return '#4488ff';
                case 'yellow': return '#ffdd44';
                case 'green': return '#44dd44';
                default: return '#ffffff';
            }
        }

        function updateShieldTimer() {
            const maxTime = shieldGame.isTutorial ? 4000 : 1500;
            const percent = (shieldGame.timeLeft / maxTime) * 100;
            document.getElementById('shieldTimerBar').style.width = percent + '%';
        }

        function handleShieldPress(color) {
            if (!shieldGame.active || !shieldGame.currentColor) return;

            clearInterval(shieldGame.timerInterval);

            if (color === shieldGame.currentColor) {
                shieldSuccess();
            } else {
                shieldMiss();
            }
        }

        function shieldSuccess() {
            shieldGame.spellsBlocked++;
            document.getElementById('shieldResult').textContent = '‚úì Blocked!';
            document.getElementById('shieldResult').className = 'shield-result success';
            document.getElementById('shieldIncoming').innerHTML = `
                <span class="shield-player-icon">üßô</span>
                <span style="color: #70c070; font-size: 28px;">üõ°Ô∏è PROTEGO!</span>
                <span class="shield-enemy-icon">${currentCreature ? currentCreature.icon : 'üßå'}</span>
            `;

            if (shieldGame.isTutorial) {
                document.getElementById('shieldHint').textContent = '‚úì Great job! Get ready for the next spell...';
            }

            playSound(800, 'sine', 0.15);
            addLog('üõ°Ô∏è Spell blocked!', 'log-effective');

            // Longer pause in tutorial
            const pauseTime = shieldGame.isTutorial ? 1200 : 600;
            setTimeout(() => {
                if (shieldGame.active) sendNextBossSpell();
            }, pauseTime);
        }

        function shieldMiss() {
            shieldGame.spellsMissed++;
            document.getElementById('shieldResult').textContent = '‚úó Hit!';
            document.getElementById('shieldResult').className = 'shield-result fail';
            document.getElementById('shieldIncoming').innerHTML = `
                <span class="shield-player-icon">üßô</span>
                <span style="color: #c07070; font-size: 28px;">üí• OUCH!</span>
                <span class="shield-enemy-icon">${currentCreature ? currentCreature.icon : 'üßå'}</span>
            `;

            if (shieldGame.isTutorial) {
                document.getElementById('shieldHint').textContent = '‚úó Missed! Try to tap the matching color faster!';
            }

            // Take damage for missed block (less damage in tutorial)
            const stats = getStats();
            const damageMultiplier = shieldGame.isTutorial ? 0.3 : 0.5;
            const damage = Math.floor(currentCreature.atk * damageMultiplier);
            game.currentHp -= damage;
            showFloat(`-${damage}`, 60, 50, 'damage');
            addLog(`üí• Hit by spell! -${damage} HP`, 'log-damage');
            playSound(200, 'sawtooth', 0.2);

            updateUI();

            // Check if player died
            if (game.currentHp <= 0) {
                endShieldMinigame();
                // Handle death directly since battle loop won't run
                gameOver();
                return;
            }

            // Brief pause then next spell
            setTimeout(() => {
                if (shieldGame.active) sendNextBossSpell();
            }, 600);
        }

        function endShieldMinigame() {
            shieldGame.active = false;
            shieldGame.currentColor = null;
            clearInterval(shieldGame.timerInterval);

            document.getElementById('shieldMinigame').classList.remove('active');
            document.querySelectorAll('.shield-btn').forEach(btn => btn.classList.remove('highlight'));

            const blocked = shieldGame.spellsBlocked;
            const total = blocked + shieldGame.spellsMissed;

            if (blocked === total && total > 0) {
                addLog(`üéâ Perfect defense! All ${total} spells blocked!`, 'log-effective');
                // Bonus damage to boss for perfect block
                const bonusDmg = Math.floor(currentCreature.maxHp * 0.1);
                creatureHp -= bonusDmg;
                showFloat(`PERFECT! -${bonusDmg}`, 220, 40, 'effective');
                playSound(1000, 'sine', 0.2);
            } else if (blocked > 0) {
                addLog(`üõ°Ô∏è Blocked ${blocked}/${total} spells`, 'log-spell');
            } else {
                addLog(`üí• Failed to block any spells!`, 'log-damage');
            }

            updateUI();

            // Resume normal battle
            if (game.currentHp > 0 && creatureHp > 0) {
                addLog('‚öîÔ∏è Resume battle!', 'log-boss');
                // Ensure battle state is correct for resuming
                game.gameStarted = true;
                game.inBattle = true;
                // Always restart the battle interval to be safe
                startBattle();
            }
        }

        // Check if we should trigger shield minigame during boss fight
        function shouldTriggerShieldMinigame() {
            if (!currentCreature || !currentCreature.boss) return false;
            if (shieldGame.active) return false;

            // Trigger at start of boss fight (first attack)
            if (!creatureBuffs.shieldPhase1) {
                creatureBuffs.shieldPhase1 = true;
                return true;
            }

            // Trigger at 50% HP
            const hpPercent = creatureHp / currentCreature.maxHp;
            if (hpPercent <= 0.5 && !creatureBuffs.shieldPhase2) {
                creatureBuffs.shieldPhase2 = true;
                return true;
            }

            return false;
        }

        init();
    </script>
</body>
</html>
